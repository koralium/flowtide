"use strict";(self.webpackChunkflowtide=self.webpackChunkflowtide||[]).push([[3128],{7485:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"connectors/mongodb","title":"MongoDB Connector","description":"The MongoDB connector allows you to insert data into a MongoDB collection.","source":"@site/docs/connectors/mongodb.md","sourceDirName":"connectors","slug":"/connectors/mongodb","permalink":"/flowtide/docs/connectors/mongodb","draft":false,"unlisted":false,"editUrl":"https://github.com/koralium/flowtide/tree/main/docs/docs/connectors/mongodb.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"CosmosDB Connector","permalink":"/flowtide/docs/connectors/cosmosdb"},"next":{"title":"Elasticsearch Connector","permalink":"/flowtide/docs/connectors/elasticsearch"}}');var a=t(4848),i=t(8453);const r={sidebar_position:2},s="MongoDB Connector",c={},l=[{value:"Sink",id:"sink",level:2},{value:"Overwriting data in a collection and cleaning up old data",id:"overwriting-data-in-a-collection-and-cleaning-up-old-data",level:3},{value:"Watermark updates",id:"watermark-updates",level:3}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"mongodb-connector",children:"MongoDB Connector"})}),"\n",(0,a.jsx)(n.p,{children:"The MongoDB connector allows you to insert data into a MongoDB collection.\nAt this time only a sink is implemented, there is no support yet to have MongoDB as a source."}),"\n",(0,a.jsx)(n.h2,{id:"sink",children:"Sink"}),"\n",(0,a.jsx)(n.p,{children:"The MongoDB sink allows the insertion of data into a MongoDB collection."}),"\n",(0,a.jsx)(n.p,{children:"The nuget package for the connector is:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"FlowtideDotNet.Connector.MongoDB"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Its implementation waits fully until the stream has reached a steady state at a time T until it writes data to the collection.\nThis means that its table output can always be traced back to a state from the source systems."}),"\n",(0,a.jsxs)(n.p,{children:["To use the ",(0,a.jsx)(n.em,{children:"MongoDB Sink"})," add the following line to the ",(0,a.jsx)(n.em,{children:"ConnectorManager"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'connectorManager.AddMongoDbSink("regex pattern for tablename", new FlowtideMongoDBSinkOptions()\n    {\n        Collection = collection, //MongoDB collection\n        Database = databaseName, // MongoDB database\n        ConnectionString = connectionString, //Connection string to MongoDB\n        PrimaryKeys = primaryKeys //List of columns that will be treated as primary keys in the collection\n    });\n'})}),"\n",(0,a.jsx)(n.h3,{id:"overwriting-data-in-a-collection-and-cleaning-up-old-data",children:"Overwriting data in a collection and cleaning up old data"}),"\n",(0,a.jsx)(n.p,{children:"It is possible with the MongoDB sink to append metadata to documents and remove data from previous runs.\nThis can be helpful when the stream is changed and you want to write to the same collection, but remove data from a previous run."}),"\n",(0,a.jsx)(n.p,{children:"To do this we add the following code:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'connectorManager.AddMongoDbSink("regex pattern for tablename", new FlowtideMongoDBSinkOptions()\n    {\n        ...\n        TransformDocument = (doc) => {\n            // version should come from configuration\n            doc.Add("_metadata", run_version);\n        },\n        OnInitialDataSent = async (collection) => {\n            await collection.DeleteManyAsync(Builders<BsonDocument>.Filter.Not(Builders<BsonDocument>.Filter.Eq("_metadata", run_version)));\n        }\n    });\n'})}),"\n",(0,a.jsx)(n.p,{children:"This will append a metadata field to all documents with the current run version.\nWhen the initial data from the stream has been saved, it will delete all documents that does not have the metadata information."}),"\n",(0,a.jsx)(n.h3,{id:"watermark-updates",children:"Watermark updates"}),"\n",(0,a.jsxs)(n.p,{children:["It is possible to listen to watermark updates, this is done by setting the ",(0,a.jsx)(n.em,{children:"OnWatermarkUpdate"})," property in the options."]}),"\n",(0,a.jsx)(n.p,{children:"Example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-csharp",children:'connectorManager.AddMongoDbSink("regex pattern for tablename", new FlowtideMongoDBSinkOptions()\n    {\n        ...\n        OnWatermarkUpdate = async (watermark) => {\n            // Inform other systems for instance about the watermark change.\n        }\n    });\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var o=t(6540);const a={},i=o.createContext(a);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);