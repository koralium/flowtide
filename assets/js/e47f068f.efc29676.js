"use strict";(self.webpackChunkflowtide=self.webpackChunkflowtide||[]).push([[7047],{1715:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"operators/normalization","title":"Normalization Operator","description":"The Normalization Operator is used mostly as a helper operator for ingestion of data.","source":"@site/docs/operators/normalization.md","sourceDirName":"operators","slug":"/operators/normalization","permalink":"/flowtide/docs/operators/normalization","draft":false,"unlisted":false,"editUrl":"https://github.com/koralium/flowtide/tree/main/docs/docs/operators/normalization.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Join Operators","permalink":"/flowtide/docs/operators/join"},"next":{"title":"Set Operator","permalink":"/flowtide/docs/operators/set"}}');var n=r(4848),i=r(8453);const a={sidebar_position:4},s="Normalization Operator",l={},d=[{value:"Metrics",id:"metrics",level:2}];function h(e){const t={admonition:"admonition",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"normalization-operator",children:"Normalization Operator"})}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.em,{children:"Normalization Operator"})," is used mostly as a helper operator for ingestion of data.\nIt takes in a list of primary keys in which it will output always one row for. An input to the normalization operator does not need\nto keep track of the differential data, but can instead send in updated values to a row, and the normalization operator will\nhandle the creation of the different delta operations needed to be sent out on the stream."]}),"\n",(0,n.jsx)(t.p,{children:"The properties it can take are:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"KeyIndex - an array of indices on which columns are for the primary key."}),"\n",(0,n.jsx)(t.li,{children:"Filter - a filter that reduces the output of the normalization operator."}),"\n",(0,n.jsx)(t.li,{children:"Input - the input operator that sends in data to this operator."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"It is a stateful operator and uses a single B+ tree to perform its operations."}),"\n",(0,n.jsx)(t.h2,{id:"metrics",children:"Metrics"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.em,{children:"Normalization Operator"})," has the following metrics:"]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Metric Name"}),(0,n.jsx)(t.th,{children:"Type"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"busy"}),(0,n.jsx)(t.td,{children:"Gauge"}),(0,n.jsx)(t.td,{children:"Value 0-1 on how busy the operator is."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"backpressure"}),(0,n.jsx)(t.td,{children:"Gauge"}),(0,n.jsx)(t.td,{children:"Value 0-1 on how much backpressure the operator has."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"health"}),(0,n.jsx)(t.td,{children:"Gauge"}),(0,n.jsx)(t.td,{children:"Value 0 or 1, if the operator is healthy or not."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"events"}),(0,n.jsx)(t.td,{children:"Counter"}),(0,n.jsx)(t.td,{children:"How many events that pass through the operator."})]})]})]}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"At this point, a normalization operator will never be unhealthy.\nIf there is a failure against the state, the stream will instead restart."})})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>a,x:()=>s});var o=r(6540);const n={},i=o.createContext(n);function a(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);