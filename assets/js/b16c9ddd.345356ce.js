"use strict";(self.webpackChunkflowtide=self.webpackChunkflowtide||[]).push([[7598],{8002:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"connectors/qdrant","title":"Qdrant connector","description":"The Qdrant connector only supports a sink, where data is stored into a Qdrant collection.","source":"@site/docs/connectors/qdrant.md","sourceDirName":"connectors","slug":"/connectors/qdrant","permalink":"/flowtide/docs/connectors/qdrant","draft":false,"unlisted":false,"editUrl":"https://github.com/koralium/flowtide/tree/main/docs/docs/connectors/qdrant.md","tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"sidebar_position":12},"sidebar":"tutorialSidebar","previous":{"title":"Files Connector","permalink":"/flowtide/docs/connectors/files"},"next":{"title":"Deployment","permalink":"/flowtide/docs/deployment/"}}');var l=n(4848),s=n(8453);const r={sidebar_position:12},d="Qdrant connector",c={},o=[{value:"Qdrant sink",id:"qdrant-sink",level:2},{value:"Special columns",id:"special-columns",level:3},{value:"Options",id:"options",level:3},{value:"Example updating alias on initialize",id:"example-updating-alias-on-initialize",level:3},{value:"Embeddings generator",id:"embeddings-generator",level:2},{value:"OpenAi embeddings generator",id:"openai-embeddings-generator",level:3},{value:"Options",id:"options-1",level:4},{value:"String chunker",id:"string-chunker",level:2},{value:"TikTokenStringChunker",id:"tiktokenstringchunker",level:3},{value:"Options",id:"options-2",level:4}];function a(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(t.header,{children:(0,l.jsx)(t.h1,{id:"qdrant-connector",children:"Qdrant connector"})}),"\n",(0,l.jsxs)(t.p,{children:["The ",(0,l.jsx)(t.em,{children:"Qdrant connector"})," only supports a sink, where data is stored into a Qdrant collection."]}),"\n",(0,l.jsx)(t.p,{children:"To use it, add the following nuget:"}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsx)(t.li,{children:"FlowtideDotNet.Connector.Qdrant"}),"\n"]}),"\n",(0,l.jsx)(t.h2,{id:"qdrant-sink",children:"Qdrant sink"}),"\n",(0,l.jsx)(t.p,{children:"The qdrant sink is used to continously update, insert and delete points in a qdrant collection."}),"\n",(0,l.jsxs)(t.p,{children:["Flowtide will add identifying metadata under the ",(0,l.jsx)(t.code,{children:"flowtide"})," key, this contains metadata that is used to track and update rows."]}),"\n",(0,l.jsxs)(t.p,{children:["It will also add some general metadata under the ",(0,l.jsx)(t.code,{children:"data"})," key (unless modified by the ",(0,l.jsx)(t.code,{children:"QdrantPayloadDataPropertyName"}),"-option), this contains information like ",(0,l.jsx)(t.code,{children:"last_update"})," and which embedding generator was used. AS well as the vectorized string (if not disabled by the ",(0,l.jsx)(t.code,{children:"QdrantIncludeVectorTextInPayload"}),"-option)."]}),"\n",(0,l.jsxs)(t.admonition,{type:"info",children:[(0,l.jsxs)(t.p,{children:["It's important that the Qdrant collection contains a payload indexes for the keys ",(0,l.jsx)(t.code,{children:"flowtide"})," and ",(0,l.jsx)(t.code,{children:"id"}),"."]}),(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:["The ",(0,l.jsx)(t.code,{children:"flowtide"})," index should be a text index."]}),"\n",(0,l.jsxs)(t.li,{children:["The ",(0,l.jsx)(t.code,{children:"id"})," index should (most likely) be a keyword index."]}),"\n"]}),(0,l.jsx)(t.p,{children:"Without these indexes resources used will be drastically higher and performance will be diminished."})]}),"\n",(0,l.jsxs)(t.p,{children:["To use it add it to the ",(0,l.jsx)(t.em,{children:"ConnectorManager"}),":"]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-csharp",children:'connectorManager.AddQdrantSink("{regexPattern}", new QdrantSinkOptions\n{\n    QdrantChannelFunc = () => QdrantChannel.ForAddress("{qdrantAddress}"),\n    CollectionName = collection,\n}, \nEmbeddingGeneratorImplementation,\nchunker);\n\n// there\'s also a built in open ai embedding generator, register by setting the OpenAiEmbeddingOptions\nconnectorManager.AddQdrantSink("{regexPattern}", new QdrantSinkOptions\n{\n    QdrantChannelFunc = () => QdrantChannel.ForAddress("{qdrantAddress}"),\n    CollectionName = collection,\n}, new OpenAiEmbeddingOptions()\n{\n    ApiKeyFunc = () => "{OpenAi api key}",\n    UrlFunc = () => "{OpenAi api url}"\n}, \nchunker);\n\n// optional string chunker\nvar chunker = new TikTokenChunker(new TikTokenChunkerOptions\n{\n    Tokenizer = TiktokenTokenizer.CreateForModel("gpt-4o"),\n    TokenChunkSize = 170,\n    TokenChunkOverlap = 20,\n});\n'})}),"\n",(0,l.jsx)(t.h3,{id:"special-columns",children:"Special columns"}),"\n",(0,l.jsx)(t.p,{children:"There are two required columns that must be selected."}),"\n",(0,l.jsxs)(t.ul,{children:["\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.strong,{children:"id"}),": The identifier/PK for the row. This can be modified with the ",(0,l.jsx)(t.code,{children:"IdColumnName"})," option."]}),"\n",(0,l.jsxs)(t.li,{children:[(0,l.jsx)(t.strong,{children:"vector_string"}),": The string content that should be vectorized. This can be modified with the ",(0,l.jsx)(t.code,{children:"VectorStringColumnName"})," option."]}),"\n"]}),"\n",(0,l.jsx)(t.h3,{id:"options",children:"Options"}),"\n",(0,l.jsx)(t.p,{children:"Options for the sink:"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"Option"}),(0,l.jsx)(t.th,{style:{textAlign:"center"},children:"required"}),(0,l.jsx)(t.th,{style:{textAlign:"center"},children:"default"}),(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,l.jsxs)(t.tbody,{children:[(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"QdrantChannelFunc"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"True"}),(0,l.jsx)(t.td,{style:{textAlign:"center"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Channel for communicating with the Qdrant instance."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"CollectionName"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"True"}),(0,l.jsx)(t.td,{style:{textAlign:"center"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"The collection name that should be used to store data."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"IdColumnName"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"True"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"id"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"The selected column that should be used as identity."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"VectorStringColumnName"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"True"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"vector_string"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"The selected column that should be vectorized."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"OnInitialize"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"false"}),(0,l.jsx)(t.td,{style:{textAlign:"center"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Hook that is run when the sink is intializing."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"OnInitialDataSent"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"false"}),(0,l.jsx)(t.td,{style:{textAlign:"center"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Hook that is run after initial data has been sent."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"OnChangesDone"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"false"}),(0,l.jsx)(t.td,{style:{textAlign:"center"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Hook that is run after changes have been handled."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Wait"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"false"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Wait for calls against Qdrant to complete before continuing."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"QdrantVectorTextPropertyName"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"text"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"The property name that should be used for the vectorized string in the payload"})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"QdrantPayloadDataPropertyName"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"data"}),(0,l.jsxs)(t.td,{style:{textAlign:"left"},children:["Under which key metadata should be added to in the Qdrant collection. This will contain information like ",(0,l.jsx)(t.code,{children:"last_update"})," and which embedding generator was used."]})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"QdrantIncludeVectorTextInPayload"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"If the vectorized string should be stored in the payload or not."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"QdrantStoreMapsUnderOwnKey"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"false"}),(0,l.jsxs)(t.td,{style:{textAlign:"left"},children:["If set to true any selected ",(0,l.jsx)(t.code,{children:"map"})," or ",(0,l.jsx)(t.code,{children:"named_struct"})," will be added under its own key in the payload"]})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"QdrantStoreListsUnderOwnKey"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"false"}),(0,l.jsxs)(t.td,{style:{textAlign:"left"},children:["If true any selected ",(0,l.jsx)(t.code,{children:"list"})," will be added under its own key in the payload."]})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"QdrantPayloadUpdateMode"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"OverWritePayload"}),(0,l.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,l.jsx)(t.code,{children:"Set"})," or ",(0,l.jsx)(t.code,{children:"overwrite"})," the payload when updating a point. ",(0,l.jsx)(t.code,{children:"Set"})," will keep any property not handled by the ",(0,l.jsx)(t.code,{children:"flowtide"})," stream, ",(0,l.jsx)(t.code,{children:"overwrite"})," will remove any such property."]})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"ResiliencePipeline"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"Incremental retries"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Resilience pipeline for requests against Qdrant. By default an incremental retry strategy that retries 10 times."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"MaxNumberOfBatchOperations"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"1000"}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"The max number of operations before the batch should be sent to Qdrant."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"MaxDepth"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"64"}),(0,l.jsxs)(t.td,{style:{textAlign:"left"},children:["The max depth of selected ",(0,l.jsx)(t.code,{children:"map"})," and ",(0,l.jsx)(t.code,{children:"named_struct"})," columns"]})]})]})]}),"\n",(0,l.jsx)(t.h3,{id:"example-updating-alias-on-initialize",children:"Example updating alias on initialize"}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-csharp",children:'OnInitialize = async (state, client) =>\n{\n    var collection = state.CollectionName;\n    // set the collection name to a unique name based on the current version of flowtide\n    // note that flowtide versioning needs to be added with, for instance, flowtideBuilder.AddVersioningFromString(...)\n    if (!string.IsNullOrWhiteSpace(state.StreamVersion?.Version))\n    {\n        collection = $"collection-{state.StreamVersion.Version}";\n    }\n\n    // if the collection does not already exist, add it to qdrant and add payload indexes\n    state.CollectionName = collection;\n    if (!await client.CollectionExistsAsync(state.CollectionName))\n    {\n        await client.CreateCollectionAsync(state.CollectionName, new VectorParams\n        {\n            // configure the collection\n            Size = 1536,\n            Distance = Distance.Cosine,\n        });\n\n        // These indexes are important as they are used by flowtide to filter and udate points\n        await client.CreatePayloadIndexAsync(state.CollectionName, "id", PayloadSchemaType.Keyword);\n        await client.CreatePayloadIndexAsync(state.CollectionName, "flowtide", PayloadSchemaType.Text);\n    }\n},\nOnInitialDataSent = async (state, client) =>\n{\n    // delete the alias from the original collection and add it to the new collection\n    await client.UpdateAliasesAsync(\n    [\n        new AliasOperations\n        {\n          DeleteAlias = new DeleteAlias\n          {\n            AliasName = alias,\n          },\n          CreateAlias = new CreateAlias\n          {\n            AliasName = alias,\n            CollectionName = state.CollectionName,\n          },\n        },\n    ]);\n\n    // delete the old collection\n    await client.DeleteCollectionAsync(state.OriginalCollectionName);\n},\n'})}),"\n",(0,l.jsx)(t.h2,{id:"embeddings-generator",children:"Embeddings generator"}),"\n",(0,l.jsxs)(t.p,{children:["An embeddings generator is required for this sink. It should implement ",(0,l.jsx)(t.code,{children:"IEmbeddingGenerator"}),"."]}),"\n",(0,l.jsx)(t.h3,{id:"openai-embeddings-generator",children:"OpenAi embeddings generator"}),"\n",(0,l.jsxs)(t.p,{children:["Embedding generator for the open ai api (",(0,l.jsx)(t.code,{children:"OpenAiEmbeddingsGenerator"}),"), but can be used for any api that matches the return type of open ai, like azure open ai for instance."]}),"\n",(0,l.jsx)(t.h4,{id:"options-1",children:"Options"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"Option"}),(0,l.jsx)(t.th,{style:{textAlign:"center"},children:"required"}),(0,l.jsx)(t.th,{style:{textAlign:"center"},children:"default"}),(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,l.jsxs)(t.tbody,{children:[(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"UrlFunc"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Url to the api."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"ApiKeyFunc"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"Api key for the api."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"MaxRequestsPerMinute"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"900"}),(0,l.jsxs)(t.td,{style:{textAlign:"left"},children:["Max number of requests per minute. This is used by the default ",(0,l.jsx)(t.code,{children:"ResiliencePipeline"}),"."]})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"ResiliencePipeline"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"Inner rate limiter with outer retry strategy."}),(0,l.jsxs)(t.td,{style:{textAlign:"left"},children:["Adds a rate limiter that permits ",(0,l.jsx)(t.code,{children:"MaxRequestsPerMinute"})," requets per minute. If the rate limiter hits its limit the retry strategy will wait upto 1 minute until the next request occurs. For general errors the retry strategy will retry 5 times incrementally before failing."]})]})]})]}),"\n",(0,l.jsx)(t.h2,{id:"string-chunker",children:"String chunker"}),"\n",(0,l.jsxs)(t.p,{children:["Optionally the sink can take a string chunker (",(0,l.jsx)(t.code,{children:"IStringChunker"}),") that splits the ",(0,l.jsx)(t.code,{children:"vector_string"})," into multiple smaller chunks."]}),"\n",(0,l.jsx)(t.h3,{id:"tiktokenstringchunker",children:"TikTokenStringChunker"}),"\n",(0,l.jsxs)(t.p,{children:["A simple chunker that removes newlines and splits the content into multiple parts with overlap based on the options ",(0,l.jsx)(t.code,{children:"TokenChunkSize"})," and ",(0,l.jsx)(t.code,{children:"TokenChunkOverlap"}),"."]}),"\n",(0,l.jsx)(t.h4,{id:"options-2",children:"Options"}),"\n",(0,l.jsxs)(t.table,{children:[(0,l.jsx)(t.thead,{children:(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"Option"}),(0,l.jsx)(t.th,{style:{textAlign:"center"},children:"required"}),(0,l.jsx)(t.th,{style:{textAlign:"center"},children:"default"}),(0,l.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,l.jsxs)(t.tbody,{children:[(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"TokenChunkSize"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"The chunk size."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"TokenChunkOverlap"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"The chunk overlap. This many tokens from the previous chunk should be added to the start of the current."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"TiktokenTokenizer"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"true"}),(0,l.jsx)(t.td,{style:{textAlign:"center"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"The tiktoken tokenizer that should be used to tokenize the content."})]}),(0,l.jsxs)(t.tr,{children:[(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"MinTokenChunkSize"}),(0,l.jsx)(t.td,{style:{textAlign:"center"},children:"false"}),(0,l.jsx)(t.td,{style:{textAlign:"center"}}),(0,l.jsx)(t.td,{style:{textAlign:"left"},children:"If a chunk is below this limit it will be merged into the previous chunk."})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,l.jsx)(t,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>d});var i=n(6540);const l={},s=i.createContext(l);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);