"use strict";(self.webpackChunkflowtide=self.webpackChunkflowtide||[]).push([[3843],{8063:(e,t,l)=>{l.r(t),l.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>n,metadata:()=>d,toc:()=>a});var i=l(4848),r=l(8453);const n={sidebar_position:0},s="General Metrics",d={id:"monitoring/generalmetrics",title:"General Metrics",description:"This section describes different general metrics that are exposed by Flowtide.",source:"@site/docs/monitoring/generalmetrics.md",sourceDirName:"monitoring",slug:"/monitoring/generalmetrics",permalink:"/flowtide/docs/monitoring/generalmetrics",draft:!1,unlisted:!1,editUrl:"https://github.com/koralium/flowtide/tree/main/docs/docs/monitoring/generalmetrics.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0},sidebar:"tutorialSidebar",previous:{title:"Monitoring",permalink:"/flowtide/docs/category/monitoring"},next:{title:"Health checks",permalink:"/flowtide/docs/monitoring/healthchecks"}},o={},a=[{value:"Standard labels",id:"standard-labels",level:2},{value:"<code>flowtide_state</code>",id:"flowtide_state",level:2},{value:"<code>flowtide_wanted_state</code>",id:"flowtide_wanted_state",level:2},{value:"<code>flowtide_health</code>",id:"flowtide_health",level:2},{value:"<code>flowtide_metadata</code>",id:"flowtide_metadata",level:2},{value:"<code>flowtide_link</code>",id:"flowtide_link",level:2},{value:"<code>flowtide_memory_allocated_bytes</code>",id:"flowtide_memory_allocated_bytes",level:2},{value:"<code>flowtide_memory_freed_bytes</code>",id:"flowtide_memory_freed_bytes",level:2},{value:"<code>flowtide_memory_allocation_count</code>",id:"flowtide_memory_allocation_count",level:2},{value:"<code>flowtide_memory_free_count</code>",id:"flowtide_memory_free_count",level:2},{value:"<code>flowtide_lru_table_cache_tries</code>",id:"flowtide_lru_table_cache_tries",level:2},{value:"<code>flowtide_lru_table_cache_misses</code>",id:"flowtide_lru_table_cache_misses",level:2},{value:"<code>flowtide_lru_table_cache_hits</code>",id:"flowtide_lru_table_cache_hits",level:2},{value:"<code>flowtide_lru_table_max_size</code>",id:"flowtide_lru_table_max_size",level:2},{value:"<code>flowtide_lru_table_size</code>",id:"flowtide_lru_table_size",level:2},{value:"<code>flowtide_lru_table_cleanup_start</code>",id:"flowtide_lru_table_cleanup_start",level:2},{value:"<code>flowtide_temporary_write_ms</code>",id:"flowtide_temporary_write_ms",level:2},{value:"<code>flowtide_temporary_read_ms</code>",id:"flowtide_temporary_read_ms",level:2},{value:"<code>flowtide_persistence_read_ms</code>",id:"flowtide_persistence_read_ms",level:2},{value:"<code>flowtide_latency</code>",id:"flowtide_latency",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"general-metrics",children:"General Metrics"})}),"\n",(0,i.jsxs)(t.p,{children:["This section describes different general metrics that are exposed by Flowtide.\nFor operator specific metrics, please check under ",(0,i.jsx)(t.a,{href:"/docs/category/operators",children:"operators"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["All metrics in flowtide are prefixed with ",(0,i.jsx)(t.code,{children:"flowtide_"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"standard-labels",children:"Standard labels"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Label Name"}),(0,i.jsx)(t.th,{children:"Scope"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"stream"}),(0,i.jsx)(t.td,{children:"Stream"}),(0,i.jsx)(t.td,{children:"Name of the stream, exist on all metrics for a stream."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"operator"}),(0,i.jsx)(t.td,{children:"Operator"}),(0,i.jsx)(t.td,{children:"Id of an operator, exist on all metrics that are specific for an operator"})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_state",children:(0,i.jsx)(t.code,{children:"flowtide_state"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Stream"}),"\n",(0,i.jsx)(t.li,{children:"Type: Gauge"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Contains the current state of the stream, only contains the stream label, the value is an integer that follows the\nstream state enum."}),"\n",(0,i.jsx)(t.p,{children:"Value table:"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Value"}),(0,i.jsx)(t.th,{children:"Name"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"0"}),(0,i.jsx)(t.td,{children:"NotStarted"}),(0,i.jsx)(t.td,{children:"The stream has either never started or has been stopped."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"1"}),(0,i.jsx)(t.td,{children:"Starting"}),(0,i.jsx)(t.td,{children:"The stream is starting up, occurs from not started or from a failure state."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"2"}),(0,i.jsx)(t.td,{children:"Running"}),(0,i.jsx)(t.td,{children:"The stream is running normally."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"3"}),(0,i.jsx)(t.td,{children:"Failure"}),(0,i.jsx)(t.td,{children:"A failure has happened and the stream will try and recover."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"4"}),(0,i.jsx)(t.td,{children:"Deleting"}),(0,i.jsx)(t.td,{children:"The stream is currently deleting itself."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"5"}),(0,i.jsx)(t.td,{children:"Deleted"}),(0,i.jsx)(t.td,{children:"The stream has finished deleting itself."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"6"}),(0,i.jsx)(t.td,{children:"Stopping"}),(0,i.jsx)(t.td,{children:"The stream is currently being stopped."})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_wanted_state",children:(0,i.jsx)(t.code,{children:"flowtide_wanted_state"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Stream"}),"\n",(0,i.jsx)(t.li,{children:"Type: Gauge"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Contains the wanted state of the stream, as an example, when one stops a stream, the wanted state is ",(0,i.jsx)(t.code,{children:"NotStarted"}),",\nbut the current state might be ",(0,i.jsx)(t.code,{children:"Stopping"}),". Uses the same value table as described in ",(0,i.jsx)(t.a,{href:"#flowtide_state",children:"flowtide_state"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_health",children:(0,i.jsx)(t.code,{children:"flowtide_health"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Stream and Operator"}),"\n",(0,i.jsx)(t.li,{children:"Type: Gauge"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The health of both the stream and operators, if no operator label exist, it is the overal stream health.\nThe value can be '0' (Unhealthy), '0.5' (Degraded) and '1' (Healthy)."}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_metadata",children:(0,i.jsx)(t.code,{children:"flowtide_metadata"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Operator"}),"\n",(0,i.jsx)(t.li,{children:"Type: Gauge"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The metadata metric only exposes labels and the value can be ignored. It exists on all operators."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Label Name"}),(0,i.jsx)(t.th,{children:"Example"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"links"}),(0,i.jsx)(t.td,{children:"[1, 2]"}),(0,i.jsx)(t.td,{children:"JSON array of operator ids that this operator sends it output to."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"title"}),(0,i.jsx)(t.td,{children:"Merge Join"}),(0,i.jsx)(t.td,{children:"Title/Display name of the operator."})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_link",children:(0,i.jsx)(t.code,{children:"flowtide_link"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Operator"}),"\n",(0,i.jsx)(t.li,{children:"Type: Gauge"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Describes an output flow from one operator to another, each output in an operator has its own metric series.\nSame as in metadata, the value is not used, and this is only described by its labels."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Label Name"}),(0,i.jsx)(t.th,{children:"Example"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"source"}),(0,i.jsx)(t.td,{children:"1"}),(0,i.jsx)(t.td,{children:"Id of the operator that the link originates from (same as 'operator' label)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"target"}),(0,i.jsx)(t.td,{children:"2"}),(0,i.jsx)(t.td,{children:"Id of the operator data flows to."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"id"}),(0,i.jsx)(t.td,{children:"1-2"}),(0,i.jsx)(t.td,{children:"Unique id of a link, to more easily identify new links if required."})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_memory_allocated_bytes",children:(0,i.jsx)(t.code,{children:"flowtide_memory_allocated_bytes"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Operator"}),"\n",(0,i.jsx)(t.li,{children:"Type: Counter"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Contains a value on how much unmanaged memory an operator has allocated. This value will never decrease, to calculate the current usage\nit must be subtracted by ",(0,i.jsx)(t.code,{children:"flowtide_memory_freed_bytes"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_memory_freed_bytes",children:(0,i.jsx)(t.code,{children:"flowtide_memory_freed_bytes"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Operator"}),"\n",(0,i.jsx)(t.li,{children:"Type: Counter"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Contains a value on how much unmanaged memory an operator has freed. The value will never decrease. Is usually used together\nwith ",(0,i.jsx)(t.code,{children:"flowtide_memory_allocated_bytes"})," to calculate current memory usage."]}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_memory_allocation_count",children:(0,i.jsx)(t.code,{children:"flowtide_memory_allocation_count"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Operator"}),"\n",(0,i.jsx)(t.li,{children:"Type: Counter"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["A counter that contains how many allocation operations has been done by an operator. Can be used together with\n",(0,i.jsx)(t.code,{children:"flowtide_memory_allocated_bytes"})," to calculate average size allocations as an example."]}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_memory_free_count",children:(0,i.jsx)(t.code,{children:"flowtide_memory_free_count"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Operator"}),"\n",(0,i.jsx)(t.li,{children:"Type: Counter"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["A counter that contains how many free operations has been done by an operator. Can be used together with\n",(0,i.jsx)(t.code,{children:"flowtide_memory_allocation_count"})," to get how many current allocations exist for an operator."]}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_lru_table_cache_tries",children:(0,i.jsx)(t.code,{children:"flowtide_lru_table_cache_tries"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Stream"}),"\n",(0,i.jsx)(t.li,{children:"Type: Counter"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["A counter that contains how many get operations have occured against the LRU cache. Used with ",(0,i.jsx)(t.code,{children:"flowtide_lru_table_cache_hits"}),"\nand ",(0,i.jsx)(t.code,{children:"flowtide_lru_table_cache_misses"})," to calculate hit and miss percentages."]}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_lru_table_cache_misses",children:(0,i.jsx)(t.code,{children:"flowtide_lru_table_cache_misses"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Stream"}),"\n",(0,i.jsx)(t.li,{children:"Type: Counter"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Contains a value on how many cache misses have occured against the LRU cache."}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_lru_table_cache_hits",children:(0,i.jsx)(t.code,{children:"flowtide_lru_table_cache_hits"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Stream"}),"\n",(0,i.jsx)(t.li,{children:"Type: Counter"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Contains a value on how many cache hits have occured against the LRU cache."}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_lru_table_max_size",children:(0,i.jsx)(t.code,{children:"flowtide_lru_table_max_size"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Stream"}),"\n",(0,i.jsx)(t.li,{children:"Type: Gauge"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Contains the value of the maximum amount of pages that can exist in the LRU cache, if this value is reached, the stream will\nhalt until pages have been offloaded to disk."}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_lru_table_size",children:(0,i.jsx)(t.code,{children:"flowtide_lru_table_size"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Stream"}),"\n",(0,i.jsx)(t.li,{children:"Type: Gauge"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Contains the current amount of pages in the LRU cache."}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_lru_table_cleanup_start",children:(0,i.jsx)(t.code,{children:"flowtide_lru_table_cleanup_start"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Stream"}),"\n",(0,i.jsx)(t.li,{children:"Type: Gauge"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Contains the value where offloading to disk will occur. Before this value no pages will be written to disk."}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_temporary_write_ms",children:(0,i.jsx)(t.code,{children:"flowtide_temporary_write_ms"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Operator"}),"\n",(0,i.jsx)(t.li,{children:"Type: Histogram"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"A histogram that describes how long it takes to write to temporary storage from LRU cache."}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_temporary_read_ms",children:(0,i.jsx)(t.code,{children:"flowtide_temporary_read_ms"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Operator"}),"\n",(0,i.jsx)(t.li,{children:"Type: Histogram"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"A histogram that describes how long it takes to read from temporary storage into LRU cache."}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_persistence_read_ms",children:(0,i.jsx)(t.code,{children:"flowtide_persistence_read_ms"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Operator"}),"\n",(0,i.jsx)(t.li,{children:"Type: Histogram"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"A histogram that describes how long it takes to read from persistent storage into LRU cache."}),"\n",(0,i.jsx)(t.h2,{id:"flowtide_latency",children:(0,i.jsx)(t.code,{children:"flowtide_latency"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scope: Operator"}),"\n",(0,i.jsx)(t.li,{children:"Type: Histogram"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Histogram that describes how long time it takes for a watermark to traverse the stream. Each egress point\nhas a histogram per source operator that produces watermarks. This allows a developer to gain\nunderstanding how quickly events can be resolved in the stream."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,l)=>{l.d(t,{R:()=>s,x:()=>d});var i=l(6540);const r={},n=i.createContext(r);function s(e){const t=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(n.Provider,{value:t},e.children)}}}]);