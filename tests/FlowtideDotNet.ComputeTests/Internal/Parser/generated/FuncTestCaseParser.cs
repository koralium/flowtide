//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from ./grammar/FuncTestCaseParser.g4 by ANTLR 4.13.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.1")]
[System.CLSCompliant(false)]
public partial class FuncTestCaseParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		Whitespace=1, TripleHash=2, SubstraitScalarTest=3, SubstraitAggregateTest=4, 
		SubstraitInclude=5, FormatVersion=6, DescriptionLine=7, Define=8, ErrorResult=9, 
		UndefineResult=10, Overflow=11, Rounding=12, Error=13, Saturate=14, Silent=15, 
		TieToEven=16, NaN=17, AcceptNulls=18, IgnoreNulls=19, NullHandling=20, 
		SpacesOnly=21, Truncate=22, IntegerLiteral=23, DecimalLiteral=24, FloatLiteral=25, 
		BooleanLiteral=26, TimestampTzLiteral=27, TimestampLiteral=28, TimeLiteral=29, 
		DateLiteral=30, PeriodPrefix=31, TimePrefix=32, YearPrefix=33, MSuffix=34, 
		DaySuffix=35, HourSuffix=36, SecondSuffix=37, FractionalSecondSuffix=38, 
		OAngleBracket=39, CAngleBracket=40, IntervalYearLiteral=41, IntervalDayLiteral=42, 
		NullLiteral=43, StringLiteral=44, ColumnName=45, LineComment=46, BlockComment=47, 
		If=48, Then=49, Else=50, Boolean=51, I8=52, I16=53, I32=54, I64=55, FP32=56, 
		FP64=57, String=58, Binary=59, Timestamp=60, Timestamp_TZ=61, Date=62, 
		Time=63, Interval_Year=64, Interval_Day=65, UUID=66, Decimal=67, Precision_Timestamp=68, 
		Precision_Timestamp_TZ=69, FixedChar=70, VarChar=71, FixedBinary=72, Struct=73, 
		NStruct=74, List=75, Map=76, UserDefined=77, Bool=78, Str=79, VBin=80, 
		Ts=81, TsTZ=82, IYear=83, IDay=84, Dec=85, PTs=86, PTsTZ=87, FChar=88, 
		VChar=89, FBin=90, Any=91, AnyVar=92, DoubleColon=93, Plus=94, Minus=95, 
		Asterisk=96, ForwardSlash=97, Percent=98, Eq=99, Ne=100, Gte=101, Lte=102, 
		Gt=103, Lt=104, Bang=105, OParen=106, CParen=107, OBracket=108, CBracket=109, 
		Comma=110, Colon=111, QMark=112, Hash=113, Dot=114, And=115, Or=116, Assign=117, 
		Number=118, Identifier=119, Newline=120;
	public const int
		RULE_doc = 0, RULE_header = 1, RULE_version = 2, RULE_include = 3, RULE_testGroupDescription = 4, 
		RULE_testCase = 5, RULE_testGroup = 6, RULE_arguments = 7, RULE_result = 8, 
		RULE_argument = 9, RULE_aggFuncTestCase = 10, RULE_aggFuncCall = 11, RULE_tableData = 12, 
		RULE_tableRows = 13, RULE_dataColumn = 14, RULE_columnValues = 15, RULE_literal = 16, 
		RULE_qualifiedAggregateFuncArgs = 17, RULE_aggregateFuncArgs = 18, RULE_qualifiedAggregateFuncArg = 19, 
		RULE_aggregateFuncArg = 20, RULE_numericLiteral = 21, RULE_floatLiteral = 22, 
		RULE_nullArg = 23, RULE_intArg = 24, RULE_floatArg = 25, RULE_decimalArg = 26, 
		RULE_booleanArg = 27, RULE_stringArg = 28, RULE_dateArg = 29, RULE_timeArg = 30, 
		RULE_timestampArg = 31, RULE_timestampTzArg = 32, RULE_intervalYearArg = 33, 
		RULE_intervalDayArg = 34, RULE_fixedCharArg = 35, RULE_varCharArg = 36, 
		RULE_fixedBinaryArg = 37, RULE_precisionTimestampArg = 38, RULE_precisionTimestampTZArg = 39, 
		RULE_listArg = 40, RULE_literalList = 41, RULE_dataType = 42, RULE_scalarType = 43, 
		RULE_booleanType = 44, RULE_stringType = 45, RULE_binaryType = 46, RULE_timestampType = 47, 
		RULE_timestampTZType = 48, RULE_intervalYearType = 49, RULE_intervalDayType = 50, 
		RULE_fixedCharType = 51, RULE_varCharType = 52, RULE_fixedBinaryType = 53, 
		RULE_decimalType = 54, RULE_precisionTimestampType = 55, RULE_precisionTimestampTZType = 56, 
		RULE_listType = 57, RULE_parameterizedType = 58, RULE_numericParameter = 59, 
		RULE_substraitError = 60, RULE_funcOption = 61, RULE_optionName = 62, 
		RULE_optionValue = 63, RULE_funcOptions = 64, RULE_nonReserved = 65, RULE_identifier = 66;
	public static readonly string[] ruleNames = {
		"doc", "header", "version", "include", "testGroupDescription", "testCase", 
		"testGroup", "arguments", "result", "argument", "aggFuncTestCase", "aggFuncCall", 
		"tableData", "tableRows", "dataColumn", "columnValues", "literal", "qualifiedAggregateFuncArgs", 
		"aggregateFuncArgs", "qualifiedAggregateFuncArg", "aggregateFuncArg", 
		"numericLiteral", "floatLiteral", "nullArg", "intArg", "floatArg", "decimalArg", 
		"booleanArg", "stringArg", "dateArg", "timeArg", "timestampArg", "timestampTzArg", 
		"intervalYearArg", "intervalDayArg", "fixedCharArg", "varCharArg", "fixedBinaryArg", 
		"precisionTimestampArg", "precisionTimestampTZArg", "listArg", "literalList", 
		"dataType", "scalarType", "booleanType", "stringType", "binaryType", "timestampType", 
		"timestampTZType", "intervalYearType", "intervalDayType", "fixedCharType", 
		"varCharType", "fixedBinaryType", "decimalType", "precisionTimestampType", 
		"precisionTimestampTZType", "listType", "parameterizedType", "numericParameter", 
		"substraitError", "funcOption", "optionName", "optionValue", "funcOptions", 
		"nonReserved", "identifier"
	};

	private static readonly string[] _LiteralNames = {
		null, null, "'###'", "'SUBSTRAIT_SCALAR_TEST'", "'SUBSTRAIT_AGGREGATE_TEST'", 
		"'SUBSTRAIT_INCLUDE'", null, null, "'DEFINE'", "'<!ERROR>'", "'<!UNDEFINED>'", 
		"'OVERFLOW'", "'ROUNDING'", "'ERROR'", "'SATURATE'", "'SILENT'", "'TIE_TO_EVEN'", 
		"'NAN'", "'ACCEPT_NULLS'", "'IGNORE_NULLS'", "'NULL_HANDLING'", "'SPACES_ONLY'", 
		"'TRUNCATE'", null, null, null, null, null, null, null, null, "'P'", "'T'", 
		"'Y'", "'M'", "'D'", "'H'", "'S'", "'F'", null, null, null, null, "'null'", 
		null, null, null, null, "'IF'", "'THEN'", "'ELSE'", "'BOOLEAN'", "'I8'", 
		"'I16'", "'I32'", "'I64'", "'FP32'", "'FP64'", "'STRING'", "'BINARY'", 
		"'TIMESTAMP'", "'TIMESTAMP_TZ'", "'DATE'", "'TIME'", "'INTERVAL_YEAR'", 
		"'INTERVAL_DAY'", "'UUID'", "'DECIMAL'", "'PRECISION_TIMESTAMP'", "'PRECISION_TIMESTAMP_TZ'", 
		"'FIXEDCHAR'", "'VARCHAR'", "'FIXEDBINARY'", "'STRUCT'", "'NSTRUCT'", 
		"'LIST'", "'MAP'", "'U!'", "'BOOL'", "'STR'", "'VBIN'", "'TS'", "'TSTZ'", 
		"'IYEAR'", "'IDAY'", "'DEC'", "'PTS'", "'PTSTZ'", "'FCHAR'", "'VCHAR'", 
		"'FBIN'", "'ANY'", null, "'::'", "'+'", "'-'", "'*'", "'/'", "'%'", "'='", 
		"'!='", "'>='", "'<='", "'>'", "'<'", "'!'", "'('", "')'", "'['", "']'", 
		"','", "':'", "'?'", "'#'", "'.'", "'AND'", "'OR'", "':='"
	};
	private static readonly string[] _SymbolicNames = {
		null, "Whitespace", "TripleHash", "SubstraitScalarTest", "SubstraitAggregateTest", 
		"SubstraitInclude", "FormatVersion", "DescriptionLine", "Define", "ErrorResult", 
		"UndefineResult", "Overflow", "Rounding", "Error", "Saturate", "Silent", 
		"TieToEven", "NaN", "AcceptNulls", "IgnoreNulls", "NullHandling", "SpacesOnly", 
		"Truncate", "IntegerLiteral", "DecimalLiteral", "FloatLiteral", "BooleanLiteral", 
		"TimestampTzLiteral", "TimestampLiteral", "TimeLiteral", "DateLiteral", 
		"PeriodPrefix", "TimePrefix", "YearPrefix", "MSuffix", "DaySuffix", "HourSuffix", 
		"SecondSuffix", "FractionalSecondSuffix", "OAngleBracket", "CAngleBracket", 
		"IntervalYearLiteral", "IntervalDayLiteral", "NullLiteral", "StringLiteral", 
		"ColumnName", "LineComment", "BlockComment", "If", "Then", "Else", "Boolean", 
		"I8", "I16", "I32", "I64", "FP32", "FP64", "String", "Binary", "Timestamp", 
		"Timestamp_TZ", "Date", "Time", "Interval_Year", "Interval_Day", "UUID", 
		"Decimal", "Precision_Timestamp", "Precision_Timestamp_TZ", "FixedChar", 
		"VarChar", "FixedBinary", "Struct", "NStruct", "List", "Map", "UserDefined", 
		"Bool", "Str", "VBin", "Ts", "TsTZ", "IYear", "IDay", "Dec", "PTs", "PTsTZ", 
		"FChar", "VChar", "FBin", "Any", "AnyVar", "DoubleColon", "Plus", "Minus", 
		"Asterisk", "ForwardSlash", "Percent", "Eq", "Ne", "Gte", "Lte", "Gt", 
		"Lt", "Bang", "OParen", "CParen", "OBracket", "CBracket", "Comma", "Colon", 
		"QMark", "Hash", "Dot", "And", "Or", "Assign", "Number", "Identifier", 
		"Newline"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "FuncTestCaseParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static FuncTestCaseParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public FuncTestCaseParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public FuncTestCaseParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class DocContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public HeaderContext header() {
			return GetRuleContext<HeaderContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(FuncTestCaseParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TestGroupContext[] testGroup() {
			return GetRuleContexts<TestGroupContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TestGroupContext testGroup(int i) {
			return GetRuleContext<TestGroupContext>(i);
		}
		public DocContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_doc; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterDoc(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitDoc(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDoc(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DocContext doc() {
		DocContext _localctx = new DocContext(Context, State);
		EnterRule(_localctx, 0, RULE_doc);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 134;
			header();
			State = 136;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 135;
				testGroup();
				}
				}
				State = 138;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==DescriptionLine );
			State = 140;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public VersionContext version() {
			return GetRuleContext<VersionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IncludeContext include() {
			return GetRuleContext<IncludeContext>(0);
		}
		public HeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_header; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitHeader(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HeaderContext header() {
		HeaderContext _localctx = new HeaderContext(Context, State);
		EnterRule(_localctx, 2, RULE_header);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 142;
			version();
			State = 143;
			include();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VersionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TripleHash() { return GetToken(FuncTestCaseParser.TripleHash, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(FuncTestCaseParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FormatVersion() { return GetToken(FuncTestCaseParser.FormatVersion, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SubstraitScalarTest() { return GetToken(FuncTestCaseParser.SubstraitScalarTest, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SubstraitAggregateTest() { return GetToken(FuncTestCaseParser.SubstraitAggregateTest, 0); }
		public VersionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_version; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterVersion(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitVersion(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVersion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VersionContext version() {
		VersionContext _localctx = new VersionContext(Context, State);
		EnterRule(_localctx, 4, RULE_version);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 145;
			Match(TripleHash);
			State = 146;
			_la = TokenStream.LA(1);
			if ( !(_la==SubstraitScalarTest || _la==SubstraitAggregateTest) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 147;
			Match(Colon);
			State = 148;
			Match(FormatVersion);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IncludeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TripleHash() { return GetToken(FuncTestCaseParser.TripleHash, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SubstraitInclude() { return GetToken(FuncTestCaseParser.SubstraitInclude, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(FuncTestCaseParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] StringLiteral() { return GetTokens(FuncTestCaseParser.StringLiteral); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral(int i) {
			return GetToken(FuncTestCaseParser.StringLiteral, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(FuncTestCaseParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(FuncTestCaseParser.Comma, i);
		}
		public IncludeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_include; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterInclude(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitInclude(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInclude(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IncludeContext include() {
		IncludeContext _localctx = new IncludeContext(Context, State);
		EnterRule(_localctx, 6, RULE_include);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 150;
			Match(TripleHash);
			State = 151;
			Match(SubstraitInclude);
			State = 152;
			Match(Colon);
			State = 153;
			Match(StringLiteral);
			State = 158;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 154;
				Match(Comma);
				State = 155;
				Match(StringLiteral);
				}
				}
				State = 160;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TestGroupDescriptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DescriptionLine() { return GetToken(FuncTestCaseParser.DescriptionLine, 0); }
		public TestGroupDescriptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_testGroupDescription; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterTestGroupDescription(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitTestGroupDescription(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTestGroupDescription(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TestGroupDescriptionContext testGroupDescription() {
		TestGroupDescriptionContext _localctx = new TestGroupDescriptionContext(Context, State);
		EnterRule(_localctx, 8, RULE_testGroupDescription);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 161;
			Match(DescriptionLine);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TestCaseContext : ParserRuleContext {
		public IdentifierContext functionName;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OParen() { return GetToken(FuncTestCaseParser.OParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CParen() { return GetToken(FuncTestCaseParser.CParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eq() { return GetToken(FuncTestCaseParser.Eq, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ResultContext result() {
			return GetRuleContext<ResultContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBracket() { return GetToken(FuncTestCaseParser.OBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FuncOptionsContext funcOptions() {
			return GetRuleContext<FuncOptionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CBracket() { return GetToken(FuncTestCaseParser.CBracket, 0); }
		public TestCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_testCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterTestCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitTestCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTestCase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TestCaseContext testCase() {
		TestCaseContext _localctx = new TestCaseContext(Context, State);
		EnterRule(_localctx, 10, RULE_testCase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 163;
			_localctx.functionName = identifier();
			State = 164;
			Match(OParen);
			State = 165;
			arguments();
			State = 166;
			Match(CParen);
			State = 171;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OBracket) {
				{
				State = 167;
				Match(OBracket);
				State = 168;
				funcOptions();
				State = 169;
				Match(CBracket);
				}
			}

			State = 173;
			Match(Eq);
			State = 174;
			result();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TestGroupContext : ParserRuleContext {
		public TestGroupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_testGroup; } }
	 
		public TestGroupContext() { }
		public virtual void CopyFrom(TestGroupContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ScalarFuncTestGroupContext : TestGroupContext {
		[System.Diagnostics.DebuggerNonUserCode] public TestGroupDescriptionContext testGroupDescription() {
			return GetRuleContext<TestGroupDescriptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TestCaseContext[] testCase() {
			return GetRuleContexts<TestCaseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TestCaseContext testCase(int i) {
			return GetRuleContext<TestCaseContext>(i);
		}
		public ScalarFuncTestGroupContext(TestGroupContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterScalarFuncTestGroup(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitScalarFuncTestGroup(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScalarFuncTestGroup(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AggregateFuncTestGroupContext : TestGroupContext {
		[System.Diagnostics.DebuggerNonUserCode] public TestGroupDescriptionContext testGroupDescription() {
			return GetRuleContext<TestGroupDescriptionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AggFuncTestCaseContext[] aggFuncTestCase() {
			return GetRuleContexts<AggFuncTestCaseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AggFuncTestCaseContext aggFuncTestCase(int i) {
			return GetRuleContext<AggFuncTestCaseContext>(i);
		}
		public AggregateFuncTestGroupContext(TestGroupContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterAggregateFuncTestGroup(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitAggregateFuncTestGroup(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAggregateFuncTestGroup(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TestGroupContext testGroup() {
		TestGroupContext _localctx = new TestGroupContext(Context, State);
		EnterRule(_localctx, 12, RULE_testGroup);
		int _la;
		try {
			State = 188;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,5,Context) ) {
			case 1:
				_localctx = new ScalarFuncTestGroupContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 176;
				testGroupDescription();
				State = 178;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 177;
					testCase();
					}
					}
					State = 180;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==Truncate || ((((_la - 115)) & ~0x3f) == 0 && ((1L << (_la - 115)) & 19L) != 0) );
				}
				break;
			case 2:
				_localctx = new AggregateFuncTestGroupContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 182;
				testGroupDescription();
				State = 184;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 183;
					aggFuncTestCase();
					}
					}
					State = 186;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==Define || _la==Truncate || ((((_la - 106)) & ~0x3f) == 0 && ((1L << (_la - 106)) & 9729L) != 0) );
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(FuncTestCaseParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(FuncTestCaseParser.Comma, i);
		}
		public ArgumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arguments; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterArguments(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitArguments(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArguments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentsContext arguments() {
		ArgumentsContext _localctx = new ArgumentsContext(Context, State);
		EnterRule(_localctx, 14, RULE_arguments);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 190;
			argument();
			State = 195;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 191;
				Match(Comma);
				State = 192;
				argument();
				}
				}
				State = 197;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResultContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentContext argument() {
			return GetRuleContext<ArgumentContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubstraitErrorContext substraitError() {
			return GetRuleContext<SubstraitErrorContext>(0);
		}
		public ResultContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_result; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterResult(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitResult(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitResult(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ResultContext result() {
		ResultContext _localctx = new ResultContext(Context, State);
		EnterRule(_localctx, 16, RULE_result);
		try {
			State = 200;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NaN:
			case IntegerLiteral:
			case DecimalLiteral:
			case FloatLiteral:
			case BooleanLiteral:
			case TimestampTzLiteral:
			case TimestampLiteral:
			case TimeLiteral:
			case DateLiteral:
			case IntervalYearLiteral:
			case IntervalDayLiteral:
			case NullLiteral:
			case StringLiteral:
			case OBracket:
				EnterOuterAlt(_localctx, 1);
				{
				State = 198;
				argument();
				}
				break;
			case ErrorResult:
			case UndefineResult:
				EnterOuterAlt(_localctx, 2);
				{
				State = 199;
				substraitError();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NullArgContext nullArg() {
			return GetRuleContext<NullArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntArgContext intArg() {
			return GetRuleContext<IntArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FloatArgContext floatArg() {
			return GetRuleContext<FloatArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public BooleanArgContext booleanArg() {
			return GetRuleContext<BooleanArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StringArgContext stringArg() {
			return GetRuleContext<StringArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DecimalArgContext decimalArg() {
			return GetRuleContext<DecimalArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DateArgContext dateArg() {
			return GetRuleContext<DateArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TimeArgContext timeArg() {
			return GetRuleContext<TimeArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TimestampArgContext timestampArg() {
			return GetRuleContext<TimestampArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TimestampTzArgContext timestampTzArg() {
			return GetRuleContext<TimestampTzArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntervalYearArgContext intervalYearArg() {
			return GetRuleContext<IntervalYearArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntervalDayArgContext intervalDayArg() {
			return GetRuleContext<IntervalDayArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FixedCharArgContext fixedCharArg() {
			return GetRuleContext<FixedCharArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarCharArgContext varCharArg() {
			return GetRuleContext<VarCharArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FixedBinaryArgContext fixedBinaryArg() {
			return GetRuleContext<FixedBinaryArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrecisionTimestampArgContext precisionTimestampArg() {
			return GetRuleContext<PrecisionTimestampArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrecisionTimestampTZArgContext precisionTimestampTZArg() {
			return GetRuleContext<PrecisionTimestampTZArgContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListArgContext listArg() {
			return GetRuleContext<ListArgContext>(0);
		}
		public ArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterArgument(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitArgument(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentContext argument() {
		ArgumentContext _localctx = new ArgumentContext(Context, State);
		EnterRule(_localctx, 18, RULE_argument);
		try {
			State = 220;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,8,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 202;
				nullArg();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 203;
				intArg();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 204;
				floatArg();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 205;
				booleanArg();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 206;
				stringArg();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 207;
				decimalArg();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 208;
				dateArg();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 209;
				timeArg();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 210;
				timestampArg();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 211;
				timestampTzArg();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 212;
				intervalYearArg();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 213;
				intervalDayArg();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 214;
				fixedCharArg();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 215;
				varCharArg();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 216;
				fixedBinaryArg();
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 217;
				precisionTimestampArg();
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 218;
				precisionTimestampTZArg();
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 219;
				listArg();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AggFuncTestCaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AggFuncCallContext aggFuncCall() {
			return GetRuleContext<AggFuncCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eq() { return GetToken(FuncTestCaseParser.Eq, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ResultContext result() {
			return GetRuleContext<ResultContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBracket() { return GetToken(FuncTestCaseParser.OBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FuncOptionsContext funcOptions() {
			return GetRuleContext<FuncOptionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CBracket() { return GetToken(FuncTestCaseParser.CBracket, 0); }
		public AggFuncTestCaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aggFuncTestCase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterAggFuncTestCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitAggFuncTestCase(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAggFuncTestCase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AggFuncTestCaseContext aggFuncTestCase() {
		AggFuncTestCaseContext _localctx = new AggFuncTestCaseContext(Context, State);
		EnterRule(_localctx, 20, RULE_aggFuncTestCase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			aggFuncCall();
			State = 227;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OBracket) {
				{
				State = 223;
				Match(OBracket);
				State = 224;
				funcOptions();
				State = 225;
				Match(CBracket);
				}
			}

			State = 229;
			Match(Eq);
			State = 230;
			result();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AggFuncCallContext : ParserRuleContext {
		public AggFuncCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aggFuncCall; } }
	 
		public AggFuncCallContext() { }
		public virtual void CopyFrom(AggFuncCallContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SingleArgAggregateFuncCallContext : AggFuncCallContext {
		public IdentifierContext functName;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OParen() { return GetToken(FuncTestCaseParser.OParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DataColumnContext dataColumn() {
			return GetRuleContext<DataColumnContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CParen() { return GetToken(FuncTestCaseParser.CParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public SingleArgAggregateFuncCallContext(AggFuncCallContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterSingleArgAggregateFuncCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitSingleArgAggregateFuncCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingleArgAggregateFuncCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultiArgAggregateFuncCallContext : AggFuncCallContext {
		public IdentifierContext funcName;
		[System.Diagnostics.DebuggerNonUserCode] public TableDataContext tableData() {
			return GetRuleContext<TableDataContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OParen() { return GetToken(FuncTestCaseParser.OParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CParen() { return GetToken(FuncTestCaseParser.CParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public QualifiedAggregateFuncArgsContext qualifiedAggregateFuncArgs() {
			return GetRuleContext<QualifiedAggregateFuncArgsContext>(0);
		}
		public MultiArgAggregateFuncCallContext(AggFuncCallContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterMultiArgAggregateFuncCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitMultiArgAggregateFuncCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiArgAggregateFuncCall(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class CompactAggregateFuncCallContext : AggFuncCallContext {
		public IdentifierContext functName;
		[System.Diagnostics.DebuggerNonUserCode] public TableRowsContext tableRows() {
			return GetRuleContext<TableRowsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OParen() { return GetToken(FuncTestCaseParser.OParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CParen() { return GetToken(FuncTestCaseParser.CParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AggregateFuncArgsContext aggregateFuncArgs() {
			return GetRuleContext<AggregateFuncArgsContext>(0);
		}
		public CompactAggregateFuncCallContext(AggFuncCallContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterCompactAggregateFuncCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitCompactAggregateFuncCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCompactAggregateFuncCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AggFuncCallContext aggFuncCall() {
		AggFuncCallContext _localctx = new AggFuncCallContext(Context, State);
		EnterRule(_localctx, 22, RULE_aggFuncCall);
		int _la;
		try {
			State = 253;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Define:
				_localctx = new MultiArgAggregateFuncCallContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 232;
				tableData();
				State = 233;
				((MultiArgAggregateFuncCallContext)_localctx).funcName = identifier();
				State = 234;
				Match(OParen);
				State = 236;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 32987488059392L) != 0) || _la==OBracket || _la==Identifier) {
					{
					State = 235;
					qualifiedAggregateFuncArgs();
					}
				}

				State = 238;
				Match(CParen);
				}
				break;
			case OParen:
				_localctx = new CompactAggregateFuncCallContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 240;
				tableRows();
				State = 241;
				((CompactAggregateFuncCallContext)_localctx).functName = identifier();
				State = 242;
				Match(OParen);
				State = 244;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 68171860148224L) != 0) || _la==OBracket) {
					{
					State = 243;
					aggregateFuncArgs();
					}
				}

				State = 246;
				Match(CParen);
				}
				break;
			case Truncate:
			case And:
			case Or:
			case Identifier:
				_localctx = new SingleArgAggregateFuncCallContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 248;
				((SingleArgAggregateFuncCallContext)_localctx).functName = identifier();
				State = 249;
				Match(OParen);
				State = 250;
				dataColumn();
				State = 251;
				Match(CParen);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableDataContext : ParserRuleContext {
		public IToken tableName;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Define() { return GetToken(FuncTestCaseParser.Define, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OParen() { return GetToken(FuncTestCaseParser.OParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DataTypeContext[] dataType() {
			return GetRuleContexts<DataTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DataTypeContext dataType(int i) {
			return GetRuleContext<DataTypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CParen() { return GetToken(FuncTestCaseParser.CParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eq() { return GetToken(FuncTestCaseParser.Eq, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TableRowsContext tableRows() {
			return GetRuleContext<TableRowsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(FuncTestCaseParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(FuncTestCaseParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(FuncTestCaseParser.Comma, i);
		}
		public TableDataContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableData; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterTableData(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitTableData(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableData(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TableDataContext tableData() {
		TableDataContext _localctx = new TableDataContext(Context, State);
		EnterRule(_localctx, 24, RULE_tableData);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 255;
			Match(Define);
			State = 256;
			_localctx.tableName = Match(Identifier);
			State = 257;
			Match(OParen);
			State = 258;
			dataType();
			State = 263;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 259;
				Match(Comma);
				State = 260;
				dataType();
				}
				}
				State = 265;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 266;
			Match(CParen);
			State = 267;
			Match(Eq);
			State = 268;
			tableRows();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TableRowsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OParen() { return GetToken(FuncTestCaseParser.OParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CParen() { return GetToken(FuncTestCaseParser.CParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ColumnValuesContext[] columnValues() {
			return GetRuleContexts<ColumnValuesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnValuesContext columnValues(int i) {
			return GetRuleContext<ColumnValuesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(FuncTestCaseParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(FuncTestCaseParser.Comma, i);
		}
		public TableRowsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tableRows; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterTableRows(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitTableRows(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTableRows(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TableRowsContext tableRows() {
		TableRowsContext _localctx = new TableRowsContext(Context, State);
		EnterRule(_localctx, 26, RULE_tableRows);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 270;
			Match(OParen);
			State = 279;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OParen) {
				{
				State = 271;
				columnValues();
				State = 276;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Comma) {
					{
					{
					State = 272;
					Match(Comma);
					State = 273;
					columnValues();
					}
					}
					State = 278;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 281;
			Match(CParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DataColumnContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ColumnValuesContext columnValues() {
			return GetRuleContext<ColumnValuesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		public DataColumnContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dataColumn; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterDataColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitDataColumn(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDataColumn(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DataColumnContext dataColumn() {
		DataColumnContext _localctx = new DataColumnContext(Context, State);
		EnterRule(_localctx, 28, RULE_dataColumn);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 283;
			columnValues();
			State = 284;
			Match(DoubleColon);
			State = 285;
			dataType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnValuesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OParen() { return GetToken(FuncTestCaseParser.OParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CParen() { return GetToken(FuncTestCaseParser.CParen, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(FuncTestCaseParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(FuncTestCaseParser.Comma, i);
		}
		public ColumnValuesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnValues; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterColumnValues(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitColumnValues(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumnValues(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ColumnValuesContext columnValues() {
		ColumnValuesContext _localctx = new ColumnValuesContext(Context, State);
		EnterRule(_localctx, 30, RULE_columnValues);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 287;
			Match(OParen);
			State = 296;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 32987488059392L) != 0) || _la==OBracket) {
				{
				State = 288;
				literal();
				State = 293;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Comma) {
					{
					{
					State = 289;
					Match(Comma);
					State = 290;
					literal();
					}
					}
					State = 295;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 298;
			Match(CParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NullLiteral() { return GetToken(FuncTestCaseParser.NullLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NumericLiteralContext numericLiteral() {
			return GetRuleContext<NumericLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BooleanLiteral() { return GetToken(FuncTestCaseParser.BooleanLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(FuncTestCaseParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DateLiteral() { return GetToken(FuncTestCaseParser.DateLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TimeLiteral() { return GetToken(FuncTestCaseParser.TimeLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TimestampLiteral() { return GetToken(FuncTestCaseParser.TimestampLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TimestampTzLiteral() { return GetToken(FuncTestCaseParser.TimestampTzLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntervalYearLiteral() { return GetToken(FuncTestCaseParser.IntervalYearLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntervalDayLiteral() { return GetToken(FuncTestCaseParser.IntervalDayLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralListContext literalList() {
			return GetRuleContext<LiteralListContext>(0);
		}
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 32, RULE_literal);
		try {
			State = 311;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NullLiteral:
				EnterOuterAlt(_localctx, 1);
				{
				State = 300;
				Match(NullLiteral);
				}
				break;
			case NaN:
			case IntegerLiteral:
			case DecimalLiteral:
			case FloatLiteral:
				EnterOuterAlt(_localctx, 2);
				{
				State = 301;
				numericLiteral();
				}
				break;
			case BooleanLiteral:
				EnterOuterAlt(_localctx, 3);
				{
				State = 302;
				Match(BooleanLiteral);
				}
				break;
			case StringLiteral:
				EnterOuterAlt(_localctx, 4);
				{
				State = 303;
				Match(StringLiteral);
				}
				break;
			case DateLiteral:
				EnterOuterAlt(_localctx, 5);
				{
				State = 304;
				Match(DateLiteral);
				}
				break;
			case TimeLiteral:
				EnterOuterAlt(_localctx, 6);
				{
				State = 305;
				Match(TimeLiteral);
				}
				break;
			case TimestampLiteral:
				EnterOuterAlt(_localctx, 7);
				{
				State = 306;
				Match(TimestampLiteral);
				}
				break;
			case TimestampTzLiteral:
				EnterOuterAlt(_localctx, 8);
				{
				State = 307;
				Match(TimestampTzLiteral);
				}
				break;
			case IntervalYearLiteral:
				EnterOuterAlt(_localctx, 9);
				{
				State = 308;
				Match(IntervalYearLiteral);
				}
				break;
			case IntervalDayLiteral:
				EnterOuterAlt(_localctx, 10);
				{
				State = 309;
				Match(IntervalDayLiteral);
				}
				break;
			case OBracket:
				EnterOuterAlt(_localctx, 11);
				{
				State = 310;
				literalList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QualifiedAggregateFuncArgsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public QualifiedAggregateFuncArgContext[] qualifiedAggregateFuncArg() {
			return GetRuleContexts<QualifiedAggregateFuncArgContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public QualifiedAggregateFuncArgContext qualifiedAggregateFuncArg(int i) {
			return GetRuleContext<QualifiedAggregateFuncArgContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(FuncTestCaseParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(FuncTestCaseParser.Comma, i);
		}
		public QualifiedAggregateFuncArgsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_qualifiedAggregateFuncArgs; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterQualifiedAggregateFuncArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitQualifiedAggregateFuncArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQualifiedAggregateFuncArgs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QualifiedAggregateFuncArgsContext qualifiedAggregateFuncArgs() {
		QualifiedAggregateFuncArgsContext _localctx = new QualifiedAggregateFuncArgsContext(Context, State);
		EnterRule(_localctx, 34, RULE_qualifiedAggregateFuncArgs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 313;
			qualifiedAggregateFuncArg();
			State = 318;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 314;
				Match(Comma);
				State = 315;
				qualifiedAggregateFuncArg();
				}
				}
				State = 320;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AggregateFuncArgsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AggregateFuncArgContext[] aggregateFuncArg() {
			return GetRuleContexts<AggregateFuncArgContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AggregateFuncArgContext aggregateFuncArg(int i) {
			return GetRuleContext<AggregateFuncArgContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(FuncTestCaseParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(FuncTestCaseParser.Comma, i);
		}
		public AggregateFuncArgsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aggregateFuncArgs; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterAggregateFuncArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitAggregateFuncArgs(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAggregateFuncArgs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AggregateFuncArgsContext aggregateFuncArgs() {
		AggregateFuncArgsContext _localctx = new AggregateFuncArgsContext(Context, State);
		EnterRule(_localctx, 36, RULE_aggregateFuncArgs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 321;
			aggregateFuncArg();
			State = 326;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 322;
				Match(Comma);
				State = 323;
				aggregateFuncArg();
				}
				}
				State = 328;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QualifiedAggregateFuncArgContext : ParserRuleContext {
		public IToken tableName;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dot() { return GetToken(FuncTestCaseParser.Dot, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ColumnName() { return GetToken(FuncTestCaseParser.ColumnName, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(FuncTestCaseParser.Identifier, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentContext argument() {
			return GetRuleContext<ArgumentContext>(0);
		}
		public QualifiedAggregateFuncArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_qualifiedAggregateFuncArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterQualifiedAggregateFuncArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitQualifiedAggregateFuncArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQualifiedAggregateFuncArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QualifiedAggregateFuncArgContext qualifiedAggregateFuncArg() {
		QualifiedAggregateFuncArgContext _localctx = new QualifiedAggregateFuncArgContext(Context, State);
		EnterRule(_localctx, 38, RULE_qualifiedAggregateFuncArg);
		try {
			State = 333;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Identifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 329;
				_localctx.tableName = Match(Identifier);
				State = 330;
				Match(Dot);
				State = 331;
				Match(ColumnName);
				}
				break;
			case NaN:
			case IntegerLiteral:
			case DecimalLiteral:
			case FloatLiteral:
			case BooleanLiteral:
			case TimestampTzLiteral:
			case TimestampLiteral:
			case TimeLiteral:
			case DateLiteral:
			case IntervalYearLiteral:
			case IntervalDayLiteral:
			case NullLiteral:
			case StringLiteral:
			case OBracket:
				EnterOuterAlt(_localctx, 2);
				{
				State = 332;
				argument();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AggregateFuncArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ColumnName() { return GetToken(FuncTestCaseParser.ColumnName, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentContext argument() {
			return GetRuleContext<ArgumentContext>(0);
		}
		public AggregateFuncArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aggregateFuncArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterAggregateFuncArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitAggregateFuncArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAggregateFuncArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AggregateFuncArgContext aggregateFuncArg() {
		AggregateFuncArgContext _localctx = new AggregateFuncArgContext(Context, State);
		EnterRule(_localctx, 40, RULE_aggregateFuncArg);
		try {
			State = 339;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ColumnName:
				EnterOuterAlt(_localctx, 1);
				{
				State = 335;
				Match(ColumnName);
				State = 336;
				Match(DoubleColon);
				State = 337;
				dataType();
				}
				break;
			case NaN:
			case IntegerLiteral:
			case DecimalLiteral:
			case FloatLiteral:
			case BooleanLiteral:
			case TimestampTzLiteral:
			case TimestampLiteral:
			case TimeLiteral:
			case DateLiteral:
			case IntervalYearLiteral:
			case IntervalDayLiteral:
			case NullLiteral:
			case StringLiteral:
			case OBracket:
				EnterOuterAlt(_localctx, 2);
				{
				State = 338;
				argument();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumericLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DecimalLiteral() { return GetToken(FuncTestCaseParser.DecimalLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntegerLiteral() { return GetToken(FuncTestCaseParser.IntegerLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FloatLiteralContext floatLiteral() {
			return GetRuleContext<FloatLiteralContext>(0);
		}
		public NumericLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numericLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterNumericLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitNumericLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumericLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumericLiteralContext numericLiteral() {
		NumericLiteralContext _localctx = new NumericLiteralContext(Context, State);
		EnterRule(_localctx, 42, RULE_numericLiteral);
		try {
			State = 344;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DecimalLiteral:
				EnterOuterAlt(_localctx, 1);
				{
				State = 341;
				Match(DecimalLiteral);
				}
				break;
			case IntegerLiteral:
				EnterOuterAlt(_localctx, 2);
				{
				State = 342;
				Match(IntegerLiteral);
				}
				break;
			case NaN:
			case FloatLiteral:
				EnterOuterAlt(_localctx, 3);
				{
				State = 343;
				floatLiteral();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FloatLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FloatLiteral() { return GetToken(FuncTestCaseParser.FloatLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NaN() { return GetToken(FuncTestCaseParser.NaN, 0); }
		public FloatLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_floatLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterFloatLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitFloatLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFloatLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FloatLiteralContext floatLiteral() {
		FloatLiteralContext _localctx = new FloatLiteralContext(Context, State);
		EnterRule(_localctx, 44, RULE_floatLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 346;
			_la = TokenStream.LA(1);
			if ( !(_la==NaN || _la==FloatLiteral) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NullArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NullLiteral() { return GetToken(FuncTestCaseParser.NullLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		public NullArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nullArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterNullArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitNullArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNullArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NullArgContext nullArg() {
		NullArgContext _localctx = new NullArgContext(Context, State);
		EnterRule(_localctx, 46, RULE_nullArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 348;
			Match(NullLiteral);
			State = 349;
			Match(DoubleColon);
			State = 350;
			dataType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntegerLiteral() { return GetToken(FuncTestCaseParser.IntegerLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode I8() { return GetToken(FuncTestCaseParser.I8, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode I16() { return GetToken(FuncTestCaseParser.I16, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode I32() { return GetToken(FuncTestCaseParser.I32, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode I64() { return GetToken(FuncTestCaseParser.I64, 0); }
		public IntArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterIntArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitIntArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntArgContext intArg() {
		IntArgContext _localctx = new IntArgContext(Context, State);
		EnterRule(_localctx, 48, RULE_intArg);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 352;
			Match(IntegerLiteral);
			State = 353;
			Match(DoubleColon);
			State = 354;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 67553994410557440L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FloatArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NumericLiteralContext numericLiteral() {
			return GetRuleContext<NumericLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FP32() { return GetToken(FuncTestCaseParser.FP32, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FP64() { return GetToken(FuncTestCaseParser.FP64, 0); }
		public FloatArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_floatArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterFloatArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitFloatArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFloatArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FloatArgContext floatArg() {
		FloatArgContext _localctx = new FloatArgContext(Context, State);
		EnterRule(_localctx, 50, RULE_floatArg);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 356;
			numericLiteral();
			State = 357;
			Match(DoubleColon);
			State = 358;
			_la = TokenStream.LA(1);
			if ( !(_la==FP32 || _la==FP64) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DecimalArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NumericLiteralContext numericLiteral() {
			return GetRuleContext<NumericLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DecimalTypeContext decimalType() {
			return GetRuleContext<DecimalTypeContext>(0);
		}
		public DecimalArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_decimalArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterDecimalArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitDecimalArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDecimalArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DecimalArgContext decimalArg() {
		DecimalArgContext _localctx = new DecimalArgContext(Context, State);
		EnterRule(_localctx, 52, RULE_decimalArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 360;
			numericLiteral();
			State = 361;
			Match(DoubleColon);
			State = 362;
			decimalType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BooleanLiteral() { return GetToken(FuncTestCaseParser.BooleanLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public BooleanTypeContext booleanType() {
			return GetRuleContext<BooleanTypeContext>(0);
		}
		public BooleanArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booleanArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterBooleanArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitBooleanArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBooleanArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BooleanArgContext booleanArg() {
		BooleanArgContext _localctx = new BooleanArgContext(Context, State);
		EnterRule(_localctx, 54, RULE_booleanArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 364;
			Match(BooleanLiteral);
			State = 365;
			Match(DoubleColon);
			State = 366;
			booleanType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(FuncTestCaseParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringTypeContext stringType() {
			return GetRuleContext<StringTypeContext>(0);
		}
		public StringArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterStringArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitStringArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringArgContext stringArg() {
		StringArgContext _localctx = new StringArgContext(Context, State);
		EnterRule(_localctx, 56, RULE_stringArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 368;
			Match(StringLiteral);
			State = 369;
			Match(DoubleColon);
			State = 370;
			stringType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DateArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DateLiteral() { return GetToken(FuncTestCaseParser.DateLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Date() { return GetToken(FuncTestCaseParser.Date, 0); }
		public DateArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dateArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterDateArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitDateArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDateArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DateArgContext dateArg() {
		DateArgContext _localctx = new DateArgContext(Context, State);
		EnterRule(_localctx, 58, RULE_dateArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 372;
			Match(DateLiteral);
			State = 373;
			Match(DoubleColon);
			State = 374;
			Match(Date);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimeArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TimeLiteral() { return GetToken(FuncTestCaseParser.TimeLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Time() { return GetToken(FuncTestCaseParser.Time, 0); }
		public TimeArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timeArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterTimeArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitTimeArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTimeArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TimeArgContext timeArg() {
		TimeArgContext _localctx = new TimeArgContext(Context, State);
		EnterRule(_localctx, 60, RULE_timeArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 376;
			Match(TimeLiteral);
			State = 377;
			Match(DoubleColon);
			State = 378;
			Match(Time);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimestampArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TimestampLiteral() { return GetToken(FuncTestCaseParser.TimestampLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TimestampTypeContext timestampType() {
			return GetRuleContext<TimestampTypeContext>(0);
		}
		public TimestampArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timestampArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterTimestampArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitTimestampArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTimestampArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TimestampArgContext timestampArg() {
		TimestampArgContext _localctx = new TimestampArgContext(Context, State);
		EnterRule(_localctx, 62, RULE_timestampArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 380;
			Match(TimestampLiteral);
			State = 381;
			Match(DoubleColon);
			State = 382;
			timestampType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimestampTzArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TimestampTzLiteral() { return GetToken(FuncTestCaseParser.TimestampTzLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TimestampTZTypeContext timestampTZType() {
			return GetRuleContext<TimestampTZTypeContext>(0);
		}
		public TimestampTzArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timestampTzArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterTimestampTzArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitTimestampTzArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTimestampTzArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TimestampTzArgContext timestampTzArg() {
		TimestampTzArgContext _localctx = new TimestampTzArgContext(Context, State);
		EnterRule(_localctx, 64, RULE_timestampTzArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 384;
			Match(TimestampTzLiteral);
			State = 385;
			Match(DoubleColon);
			State = 386;
			timestampTZType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalYearArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntervalYearLiteral() { return GetToken(FuncTestCaseParser.IntervalYearLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IntervalYearTypeContext intervalYearType() {
			return GetRuleContext<IntervalYearTypeContext>(0);
		}
		public IntervalYearArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalYearArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterIntervalYearArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitIntervalYearArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntervalYearArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntervalYearArgContext intervalYearArg() {
		IntervalYearArgContext _localctx = new IntervalYearArgContext(Context, State);
		EnterRule(_localctx, 66, RULE_intervalYearArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 388;
			Match(IntervalYearLiteral);
			State = 389;
			Match(DoubleColon);
			State = 390;
			intervalYearType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalDayArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntervalDayLiteral() { return GetToken(FuncTestCaseParser.IntervalDayLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IntervalDayTypeContext intervalDayType() {
			return GetRuleContext<IntervalDayTypeContext>(0);
		}
		public IntervalDayArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalDayArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterIntervalDayArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitIntervalDayArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntervalDayArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntervalDayArgContext intervalDayArg() {
		IntervalDayArgContext _localctx = new IntervalDayArgContext(Context, State);
		EnterRule(_localctx, 68, RULE_intervalDayArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 392;
			Match(IntervalDayLiteral);
			State = 393;
			Match(DoubleColon);
			State = 394;
			intervalDayType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FixedCharArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(FuncTestCaseParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FixedCharTypeContext fixedCharType() {
			return GetRuleContext<FixedCharTypeContext>(0);
		}
		public FixedCharArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fixedCharArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterFixedCharArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitFixedCharArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFixedCharArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FixedCharArgContext fixedCharArg() {
		FixedCharArgContext _localctx = new FixedCharArgContext(Context, State);
		EnterRule(_localctx, 70, RULE_fixedCharArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 396;
			Match(StringLiteral);
			State = 397;
			Match(DoubleColon);
			State = 398;
			fixedCharType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarCharArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(FuncTestCaseParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VarCharTypeContext varCharType() {
			return GetRuleContext<VarCharTypeContext>(0);
		}
		public VarCharArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varCharArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterVarCharArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitVarCharArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarCharArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VarCharArgContext varCharArg() {
		VarCharArgContext _localctx = new VarCharArgContext(Context, State);
		EnterRule(_localctx, 72, RULE_varCharArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 400;
			Match(StringLiteral);
			State = 401;
			Match(DoubleColon);
			State = 402;
			varCharType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FixedBinaryArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode StringLiteral() { return GetToken(FuncTestCaseParser.StringLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FixedBinaryTypeContext fixedBinaryType() {
			return GetRuleContext<FixedBinaryTypeContext>(0);
		}
		public FixedBinaryArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fixedBinaryArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterFixedBinaryArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitFixedBinaryArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFixedBinaryArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FixedBinaryArgContext fixedBinaryArg() {
		FixedBinaryArgContext _localctx = new FixedBinaryArgContext(Context, State);
		EnterRule(_localctx, 74, RULE_fixedBinaryArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 404;
			Match(StringLiteral);
			State = 405;
			Match(DoubleColon);
			State = 406;
			fixedBinaryType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrecisionTimestampArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TimestampLiteral() { return GetToken(FuncTestCaseParser.TimestampLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PrecisionTimestampTypeContext precisionTimestampType() {
			return GetRuleContext<PrecisionTimestampTypeContext>(0);
		}
		public PrecisionTimestampArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_precisionTimestampArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterPrecisionTimestampArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitPrecisionTimestampArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrecisionTimestampArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrecisionTimestampArgContext precisionTimestampArg() {
		PrecisionTimestampArgContext _localctx = new PrecisionTimestampArgContext(Context, State);
		EnterRule(_localctx, 76, RULE_precisionTimestampArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 408;
			Match(TimestampLiteral);
			State = 409;
			Match(DoubleColon);
			State = 410;
			precisionTimestampType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrecisionTimestampTZArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TimestampTzLiteral() { return GetToken(FuncTestCaseParser.TimestampTzLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PrecisionTimestampTZTypeContext precisionTimestampTZType() {
			return GetRuleContext<PrecisionTimestampTZTypeContext>(0);
		}
		public PrecisionTimestampTZArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_precisionTimestampTZArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterPrecisionTimestampTZArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitPrecisionTimestampTZArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrecisionTimestampTZArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrecisionTimestampTZArgContext precisionTimestampTZArg() {
		PrecisionTimestampTZArgContext _localctx = new PrecisionTimestampTZArgContext(Context, State);
		EnterRule(_localctx, 78, RULE_precisionTimestampTZArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 412;
			Match(TimestampTzLiteral);
			State = 413;
			Match(DoubleColon);
			State = 414;
			precisionTimestampTZType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ListArgContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LiteralListContext literalList() {
			return GetRuleContext<LiteralListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DoubleColon() { return GetToken(FuncTestCaseParser.DoubleColon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ListTypeContext listType() {
			return GetRuleContext<ListTypeContext>(0);
		}
		public ListArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_listArg; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterListArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitListArg(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitListArg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ListArgContext listArg() {
		ListArgContext _localctx = new ListArgContext(Context, State);
		EnterRule(_localctx, 80, RULE_listArg);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 416;
			literalList();
			State = 417;
			Match(DoubleColon);
			State = 418;
			listType();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OBracket() { return GetToken(FuncTestCaseParser.OBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CBracket() { return GetToken(FuncTestCaseParser.CBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext[] literal() {
			return GetRuleContexts<LiteralContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal(int i) {
			return GetRuleContext<LiteralContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(FuncTestCaseParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(FuncTestCaseParser.Comma, i);
		}
		public LiteralListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterLiteralList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitLiteralList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteralList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralListContext literalList() {
		LiteralListContext _localctx = new LiteralListContext(Context, State);
		EnterRule(_localctx, 82, RULE_literalList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 420;
			Match(OBracket);
			State = 429;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 32987488059392L) != 0) || _la==OBracket) {
				{
				State = 421;
				literal();
				State = 426;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==Comma) {
					{
					{
					State = 422;
					Match(Comma);
					State = 423;
					literal();
					}
					}
					State = 428;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 431;
			Match(CBracket);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DataTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ScalarTypeContext scalarType() {
			return GetRuleContext<ScalarTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterizedTypeContext parameterizedType() {
			return GetRuleContext<ParameterizedTypeContext>(0);
		}
		public DataTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dataType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterDataType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitDataType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDataType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DataTypeContext dataType() {
		DataTypeContext _localctx = new DataTypeContext(Context, State);
		EnterRule(_localctx, 84, RULE_dataType);
		try {
			State = 435;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Boolean:
			case I8:
			case I16:
			case I32:
			case I64:
			case FP32:
			case FP64:
			case String:
			case Binary:
			case Timestamp:
			case Timestamp_TZ:
			case Date:
			case Time:
			case Interval_Year:
			case UUID:
			case UserDefined:
			case Bool:
			case Str:
			case VBin:
			case Ts:
			case TsTZ:
			case IYear:
				EnterOuterAlt(_localctx, 1);
				{
				State = 433;
				scalarType();
				}
				break;
			case Interval_Day:
			case Decimal:
			case Precision_Timestamp:
			case Precision_Timestamp_TZ:
			case FixedChar:
			case VarChar:
			case FixedBinary:
			case List:
			case IDay:
			case Dec:
			case PTs:
			case PTsTZ:
			case FChar:
			case VChar:
			case FBin:
				EnterOuterAlt(_localctx, 2);
				{
				State = 434;
				parameterizedType();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScalarTypeContext : ParserRuleContext {
		public ScalarTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scalarType; } }
	 
		public ScalarTypeContext() { }
		public virtual void CopyFrom(ScalarTypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DateContext : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Date() { return GetToken(FuncTestCaseParser.Date, 0); }
		public DateContext(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterDate(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitDate(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDate(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StringContext : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public StringTypeContext stringType() {
			return GetRuleContext<StringTypeContext>(0);
		}
		public StringContext(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitString(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitString(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class I64Context : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode I64() { return GetToken(FuncTestCaseParser.I64, 0); }
		public I64Context(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterI64(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitI64(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitI64(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UserDefinedContext : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UserDefined() { return GetToken(FuncTestCaseParser.UserDefined, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(FuncTestCaseParser.Identifier, 0); }
		public UserDefinedContext(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterUserDefined(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitUserDefined(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUserDefined(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class I32Context : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode I32() { return GetToken(FuncTestCaseParser.I32, 0); }
		public I32Context(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterI32(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitI32(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitI32(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class IntervalYearContext : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public IntervalYearTypeContext intervalYearType() {
			return GetRuleContext<IntervalYearTypeContext>(0);
		}
		public IntervalYearContext(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterIntervalYear(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitIntervalYear(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntervalYear(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UuidContext : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UUID() { return GetToken(FuncTestCaseParser.UUID, 0); }
		public UuidContext(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterUuid(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitUuid(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUuid(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class I8Context : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode I8() { return GetToken(FuncTestCaseParser.I8, 0); }
		public I8Context(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterI8(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitI8(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitI8(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class I16Context : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode I16() { return GetToken(FuncTestCaseParser.I16, 0); }
		public I16Context(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterI16(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitI16(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitI16(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BooleanContext : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public BooleanTypeContext booleanType() {
			return GetRuleContext<BooleanTypeContext>(0);
		}
		public BooleanContext(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterBoolean(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitBoolean(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBoolean(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BinaryContext : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public BinaryTypeContext binaryType() {
			return GetRuleContext<BinaryTypeContext>(0);
		}
		public BinaryContext(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterBinary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitBinary(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBinary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Fp64Context : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FP64() { return GetToken(FuncTestCaseParser.FP64, 0); }
		public Fp64Context(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterFp64(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitFp64(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFp64(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class Fp32Context : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FP32() { return GetToken(FuncTestCaseParser.FP32, 0); }
		public Fp32Context(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterFp32(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitFp32(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFp32(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TimeContext : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Time() { return GetToken(FuncTestCaseParser.Time, 0); }
		public TimeContext(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterTime(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitTime(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTime(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TimestampContext : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public TimestampTypeContext timestampType() {
			return GetRuleContext<TimestampTypeContext>(0);
		}
		public TimestampContext(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterTimestamp(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitTimestamp(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTimestamp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TimestampTzContext : ScalarTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public TimestampTZTypeContext timestampTZType() {
			return GetRuleContext<TimestampTZTypeContext>(0);
		}
		public TimestampTzContext(ScalarTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterTimestampTz(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitTimestampTz(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTimestampTz(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScalarTypeContext scalarType() {
		ScalarTypeContext _localctx = new ScalarTypeContext(Context, State);
		EnterRule(_localctx, 86, RULE_scalarType);
		try {
			State = 454;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Boolean:
			case Bool:
				_localctx = new BooleanContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 437;
				booleanType();
				}
				break;
			case I8:
				_localctx = new I8Context(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 438;
				Match(I8);
				}
				break;
			case I16:
				_localctx = new I16Context(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 439;
				Match(I16);
				}
				break;
			case I32:
				_localctx = new I32Context(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 440;
				Match(I32);
				}
				break;
			case I64:
				_localctx = new I64Context(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 441;
				Match(I64);
				}
				break;
			case FP32:
				_localctx = new Fp32Context(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 442;
				Match(FP32);
				}
				break;
			case FP64:
				_localctx = new Fp64Context(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 443;
				Match(FP64);
				}
				break;
			case String:
			case Str:
				_localctx = new StringContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 444;
				stringType();
				}
				break;
			case Binary:
			case VBin:
				_localctx = new BinaryContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 445;
				binaryType();
				}
				break;
			case Timestamp:
			case Ts:
				_localctx = new TimestampContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 446;
				timestampType();
				}
				break;
			case Timestamp_TZ:
			case TsTZ:
				_localctx = new TimestampTzContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 447;
				timestampTZType();
				}
				break;
			case Date:
				_localctx = new DateContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 448;
				Match(Date);
				}
				break;
			case Time:
				_localctx = new TimeContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 449;
				Match(Time);
				}
				break;
			case Interval_Year:
			case IYear:
				_localctx = new IntervalYearContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 450;
				intervalYearType();
				}
				break;
			case UUID:
				_localctx = new UuidContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 451;
				Match(UUID);
				}
				break;
			case UserDefined:
				_localctx = new UserDefinedContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 452;
				Match(UserDefined);
				State = 453;
				Match(Identifier);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BooleanTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Bool() { return GetToken(FuncTestCaseParser.Bool, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Boolean() { return GetToken(FuncTestCaseParser.Boolean, 0); }
		public BooleanTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_booleanType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterBooleanType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitBooleanType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBooleanType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BooleanTypeContext booleanType() {
		BooleanTypeContext _localctx = new BooleanTypeContext(Context, State);
		EnterRule(_localctx, 88, RULE_booleanType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 456;
			_la = TokenStream.LA(1);
			if ( !(_la==Boolean || _la==Bool) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Str() { return GetToken(FuncTestCaseParser.Str, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode String() { return GetToken(FuncTestCaseParser.String, 0); }
		public StringTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterStringType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitStringType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringTypeContext stringType() {
		StringTypeContext _localctx = new StringTypeContext(Context, State);
		EnterRule(_localctx, 90, RULE_stringType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 458;
			_la = TokenStream.LA(1);
			if ( !(_la==String || _la==Str) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BinaryTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Binary() { return GetToken(FuncTestCaseParser.Binary, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VBin() { return GetToken(FuncTestCaseParser.VBin, 0); }
		public BinaryTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_binaryType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterBinaryType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitBinaryType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBinaryType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BinaryTypeContext binaryType() {
		BinaryTypeContext _localctx = new BinaryTypeContext(Context, State);
		EnterRule(_localctx, 92, RULE_binaryType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 460;
			_la = TokenStream.LA(1);
			if ( !(_la==Binary || _la==VBin) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimestampTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Ts() { return GetToken(FuncTestCaseParser.Ts, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Timestamp() { return GetToken(FuncTestCaseParser.Timestamp, 0); }
		public TimestampTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timestampType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterTimestampType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitTimestampType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTimestampType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TimestampTypeContext timestampType() {
		TimestampTypeContext _localctx = new TimestampTypeContext(Context, State);
		EnterRule(_localctx, 94, RULE_timestampType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 462;
			_la = TokenStream.LA(1);
			if ( !(_la==Timestamp || _la==Ts) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TimestampTZTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TsTZ() { return GetToken(FuncTestCaseParser.TsTZ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Timestamp_TZ() { return GetToken(FuncTestCaseParser.Timestamp_TZ, 0); }
		public TimestampTZTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_timestampTZType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterTimestampTZType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitTimestampTZType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTimestampTZType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TimestampTZTypeContext timestampTZType() {
		TimestampTZTypeContext _localctx = new TimestampTZTypeContext(Context, State);
		EnterRule(_localctx, 96, RULE_timestampTZType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 464;
			_la = TokenStream.LA(1);
			if ( !(_la==Timestamp_TZ || _la==TsTZ) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalYearTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IYear() { return GetToken(FuncTestCaseParser.IYear, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Interval_Year() { return GetToken(FuncTestCaseParser.Interval_Year, 0); }
		public IntervalYearTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalYearType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterIntervalYearType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitIntervalYearType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntervalYearType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntervalYearTypeContext intervalYearType() {
		IntervalYearTypeContext _localctx = new IntervalYearTypeContext(Context, State);
		EnterRule(_localctx, 98, RULE_intervalYearType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 466;
			_la = TokenStream.LA(1);
			if ( !(_la==Interval_Year || _la==IYear) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntervalDayTypeContext : ParserRuleContext {
		public IToken isnull;
		public NumericParameterContext len;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDay() { return GetToken(FuncTestCaseParser.IDay, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Interval_Day() { return GetToken(FuncTestCaseParser.Interval_Day, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OAngleBracket() { return GetToken(FuncTestCaseParser.OAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CAngleBracket() { return GetToken(FuncTestCaseParser.CAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QMark() { return GetToken(FuncTestCaseParser.QMark, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NumericParameterContext numericParameter() {
			return GetRuleContext<NumericParameterContext>(0);
		}
		public IntervalDayTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_intervalDayType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterIntervalDayType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitIntervalDayType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntervalDayType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IntervalDayTypeContext intervalDayType() {
		IntervalDayTypeContext _localctx = new IntervalDayTypeContext(Context, State);
		EnterRule(_localctx, 100, RULE_intervalDayType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 468;
			_la = TokenStream.LA(1);
			if ( !(_la==Interval_Day || _la==IDay) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 470;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==QMark) {
				{
				State = 469;
				_localctx.isnull = Match(QMark);
				}
			}

			State = 476;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OAngleBracket) {
				{
				State = 472;
				Match(OAngleBracket);
				State = 473;
				_localctx.len = numericParameter();
				State = 474;
				Match(CAngleBracket);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FixedCharTypeContext : ParserRuleContext {
		public IToken isnull;
		public NumericParameterContext len;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OAngleBracket() { return GetToken(FuncTestCaseParser.OAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CAngleBracket() { return GetToken(FuncTestCaseParser.CAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FChar() { return GetToken(FuncTestCaseParser.FChar, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FixedChar() { return GetToken(FuncTestCaseParser.FixedChar, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NumericParameterContext numericParameter() {
			return GetRuleContext<NumericParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QMark() { return GetToken(FuncTestCaseParser.QMark, 0); }
		public FixedCharTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fixedCharType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterFixedCharType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitFixedCharType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFixedCharType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FixedCharTypeContext fixedCharType() {
		FixedCharTypeContext _localctx = new FixedCharTypeContext(Context, State);
		EnterRule(_localctx, 102, RULE_fixedCharType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 478;
			_la = TokenStream.LA(1);
			if ( !(_la==FixedChar || _la==FChar) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 480;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==QMark) {
				{
				State = 479;
				_localctx.isnull = Match(QMark);
				}
			}

			State = 482;
			Match(OAngleBracket);
			State = 483;
			_localctx.len = numericParameter();
			State = 484;
			Match(CAngleBracket);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VarCharTypeContext : ParserRuleContext {
		public IToken isnull;
		public NumericParameterContext len;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OAngleBracket() { return GetToken(FuncTestCaseParser.OAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CAngleBracket() { return GetToken(FuncTestCaseParser.CAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VChar() { return GetToken(FuncTestCaseParser.VChar, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VarChar() { return GetToken(FuncTestCaseParser.VarChar, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NumericParameterContext numericParameter() {
			return GetRuleContext<NumericParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QMark() { return GetToken(FuncTestCaseParser.QMark, 0); }
		public VarCharTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_varCharType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterVarCharType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitVarCharType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVarCharType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VarCharTypeContext varCharType() {
		VarCharTypeContext _localctx = new VarCharTypeContext(Context, State);
		EnterRule(_localctx, 104, RULE_varCharType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 486;
			_la = TokenStream.LA(1);
			if ( !(_la==VarChar || _la==VChar) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 488;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==QMark) {
				{
				State = 487;
				_localctx.isnull = Match(QMark);
				}
			}

			State = 490;
			Match(OAngleBracket);
			State = 491;
			_localctx.len = numericParameter();
			State = 492;
			Match(CAngleBracket);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FixedBinaryTypeContext : ParserRuleContext {
		public IToken isnull;
		public NumericParameterContext len;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OAngleBracket() { return GetToken(FuncTestCaseParser.OAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CAngleBracket() { return GetToken(FuncTestCaseParser.CAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FBin() { return GetToken(FuncTestCaseParser.FBin, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FixedBinary() { return GetToken(FuncTestCaseParser.FixedBinary, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NumericParameterContext numericParameter() {
			return GetRuleContext<NumericParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QMark() { return GetToken(FuncTestCaseParser.QMark, 0); }
		public FixedBinaryTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fixedBinaryType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterFixedBinaryType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitFixedBinaryType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFixedBinaryType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FixedBinaryTypeContext fixedBinaryType() {
		FixedBinaryTypeContext _localctx = new FixedBinaryTypeContext(Context, State);
		EnterRule(_localctx, 106, RULE_fixedBinaryType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 494;
			_la = TokenStream.LA(1);
			if ( !(_la==FixedBinary || _la==FBin) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 496;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==QMark) {
				{
				State = 495;
				_localctx.isnull = Match(QMark);
				}
			}

			State = 498;
			Match(OAngleBracket);
			State = 499;
			_localctx.len = numericParameter();
			State = 500;
			Match(CAngleBracket);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DecimalTypeContext : ParserRuleContext {
		public IToken isnull;
		public NumericParameterContext precision;
		public NumericParameterContext scale;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Dec() { return GetToken(FuncTestCaseParser.Dec, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Decimal() { return GetToken(FuncTestCaseParser.Decimal, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OAngleBracket() { return GetToken(FuncTestCaseParser.OAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma() { return GetToken(FuncTestCaseParser.Comma, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CAngleBracket() { return GetToken(FuncTestCaseParser.CAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QMark() { return GetToken(FuncTestCaseParser.QMark, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NumericParameterContext[] numericParameter() {
			return GetRuleContexts<NumericParameterContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NumericParameterContext numericParameter(int i) {
			return GetRuleContext<NumericParameterContext>(i);
		}
		public DecimalTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_decimalType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterDecimalType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitDecimalType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDecimalType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DecimalTypeContext decimalType() {
		DecimalTypeContext _localctx = new DecimalTypeContext(Context, State);
		EnterRule(_localctx, 108, RULE_decimalType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 502;
			_la = TokenStream.LA(1);
			if ( !(_la==Decimal || _la==Dec) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 504;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==QMark) {
				{
				State = 503;
				_localctx.isnull = Match(QMark);
				}
			}

			State = 512;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OAngleBracket) {
				{
				State = 506;
				Match(OAngleBracket);
				State = 507;
				_localctx.precision = numericParameter();
				State = 508;
				Match(Comma);
				State = 509;
				_localctx.scale = numericParameter();
				State = 510;
				Match(CAngleBracket);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrecisionTimestampTypeContext : ParserRuleContext {
		public IToken isnull;
		public NumericParameterContext precision;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OAngleBracket() { return GetToken(FuncTestCaseParser.OAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CAngleBracket() { return GetToken(FuncTestCaseParser.CAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PTs() { return GetToken(FuncTestCaseParser.PTs, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Precision_Timestamp() { return GetToken(FuncTestCaseParser.Precision_Timestamp, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NumericParameterContext numericParameter() {
			return GetRuleContext<NumericParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QMark() { return GetToken(FuncTestCaseParser.QMark, 0); }
		public PrecisionTimestampTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_precisionTimestampType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterPrecisionTimestampType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitPrecisionTimestampType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrecisionTimestampType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrecisionTimestampTypeContext precisionTimestampType() {
		PrecisionTimestampTypeContext _localctx = new PrecisionTimestampTypeContext(Context, State);
		EnterRule(_localctx, 110, RULE_precisionTimestampType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 514;
			_la = TokenStream.LA(1);
			if ( !(_la==Precision_Timestamp || _la==PTs) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 516;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==QMark) {
				{
				State = 515;
				_localctx.isnull = Match(QMark);
				}
			}

			State = 518;
			Match(OAngleBracket);
			State = 519;
			_localctx.precision = numericParameter();
			State = 520;
			Match(CAngleBracket);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrecisionTimestampTZTypeContext : ParserRuleContext {
		public IToken isnull;
		public NumericParameterContext precision;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OAngleBracket() { return GetToken(FuncTestCaseParser.OAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CAngleBracket() { return GetToken(FuncTestCaseParser.CAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PTsTZ() { return GetToken(FuncTestCaseParser.PTsTZ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Precision_Timestamp_TZ() { return GetToken(FuncTestCaseParser.Precision_Timestamp_TZ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NumericParameterContext numericParameter() {
			return GetRuleContext<NumericParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QMark() { return GetToken(FuncTestCaseParser.QMark, 0); }
		public PrecisionTimestampTZTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_precisionTimestampTZType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterPrecisionTimestampTZType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitPrecisionTimestampTZType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrecisionTimestampTZType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrecisionTimestampTZTypeContext precisionTimestampTZType() {
		PrecisionTimestampTZTypeContext _localctx = new PrecisionTimestampTZTypeContext(Context, State);
		EnterRule(_localctx, 112, RULE_precisionTimestampTZType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 522;
			_la = TokenStream.LA(1);
			if ( !(_la==Precision_Timestamp_TZ || _la==PTsTZ) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 524;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==QMark) {
				{
				State = 523;
				_localctx.isnull = Match(QMark);
				}
			}

			State = 526;
			Match(OAngleBracket);
			State = 527;
			_localctx.precision = numericParameter();
			State = 528;
			Match(CAngleBracket);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ListTypeContext : ParserRuleContext {
		public ListTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_listType; } }
	 
		public ListTypeContext() { }
		public virtual void CopyFrom(ListTypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ListContext : ListTypeContext {
		public IToken isnull;
		public DataTypeContext elemType;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode List() { return GetToken(FuncTestCaseParser.List, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OAngleBracket() { return GetToken(FuncTestCaseParser.OAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CAngleBracket() { return GetToken(FuncTestCaseParser.CAngleBracket, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DataTypeContext dataType() {
			return GetRuleContext<DataTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QMark() { return GetToken(FuncTestCaseParser.QMark, 0); }
		public ListContext(ListTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ListTypeContext listType() {
		ListTypeContext _localctx = new ListTypeContext(Context, State);
		EnterRule(_localctx, 114, RULE_listType);
		int _la;
		try {
			_localctx = new ListContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 530;
			Match(List);
			State = 532;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==QMark) {
				{
				State = 531;
				((ListContext)_localctx).isnull = Match(QMark);
				}
			}

			State = 534;
			Match(OAngleBracket);
			State = 535;
			((ListContext)_localctx).elemType = dataType();
			State = 536;
			Match(CAngleBracket);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterizedTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FixedCharTypeContext fixedCharType() {
			return GetRuleContext<FixedCharTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VarCharTypeContext varCharType() {
			return GetRuleContext<VarCharTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FixedBinaryTypeContext fixedBinaryType() {
			return GetRuleContext<FixedBinaryTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DecimalTypeContext decimalType() {
			return GetRuleContext<DecimalTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public IntervalDayTypeContext intervalDayType() {
			return GetRuleContext<IntervalDayTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrecisionTimestampTypeContext precisionTimestampType() {
			return GetRuleContext<PrecisionTimestampTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrecisionTimestampTZTypeContext precisionTimestampTZType() {
			return GetRuleContext<PrecisionTimestampTZTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListTypeContext listType() {
			return GetRuleContext<ListTypeContext>(0);
		}
		public ParameterizedTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterizedType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitParameterizedType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterizedType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterizedTypeContext parameterizedType() {
		ParameterizedTypeContext _localctx = new ParameterizedTypeContext(Context, State);
		EnterRule(_localctx, 116, RULE_parameterizedType);
		try {
			State = 546;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case FixedChar:
			case FChar:
				EnterOuterAlt(_localctx, 1);
				{
				State = 538;
				fixedCharType();
				}
				break;
			case VarChar:
			case VChar:
				EnterOuterAlt(_localctx, 2);
				{
				State = 539;
				varCharType();
				}
				break;
			case FixedBinary:
			case FBin:
				EnterOuterAlt(_localctx, 3);
				{
				State = 540;
				fixedBinaryType();
				}
				break;
			case Decimal:
			case Dec:
				EnterOuterAlt(_localctx, 4);
				{
				State = 541;
				decimalType();
				}
				break;
			case Interval_Day:
			case IDay:
				EnterOuterAlt(_localctx, 5);
				{
				State = 542;
				intervalDayType();
				}
				break;
			case Precision_Timestamp:
			case PTs:
				EnterOuterAlt(_localctx, 6);
				{
				State = 543;
				precisionTimestampType();
				}
				break;
			case Precision_Timestamp_TZ:
			case PTsTZ:
				EnterOuterAlt(_localctx, 7);
				{
				State = 544;
				precisionTimestampTZType();
				}
				break;
			case List:
				EnterOuterAlt(_localctx, 8);
				{
				State = 545;
				listType();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumericParameterContext : ParserRuleContext {
		public NumericParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numericParameter; } }
	 
		public NumericParameterContext() { }
		public virtual void CopyFrom(NumericParameterContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IntegerLiteralContext : NumericParameterContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IntegerLiteral() { return GetToken(FuncTestCaseParser.IntegerLiteral, 0); }
		public IntegerLiteralContext(NumericParameterContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterIntegerLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitIntegerLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIntegerLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumericParameterContext numericParameter() {
		NumericParameterContext _localctx = new NumericParameterContext(Context, State);
		EnterRule(_localctx, 118, RULE_numericParameter);
		try {
			_localctx = new IntegerLiteralContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 548;
			Match(IntegerLiteral);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubstraitErrorContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ErrorResult() { return GetToken(FuncTestCaseParser.ErrorResult, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UndefineResult() { return GetToken(FuncTestCaseParser.UndefineResult, 0); }
		public SubstraitErrorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_substraitError; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterSubstraitError(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitSubstraitError(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubstraitError(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubstraitErrorContext substraitError() {
		SubstraitErrorContext _localctx = new SubstraitErrorContext(Context, State);
		EnterRule(_localctx, 120, RULE_substraitError);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 550;
			_la = TokenStream.LA(1);
			if ( !(_la==ErrorResult || _la==UndefineResult) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OptionNameContext optionName() {
			return GetRuleContext<OptionNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Colon() { return GetToken(FuncTestCaseParser.Colon, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OptionValueContext optionValue() {
			return GetRuleContext<OptionValueContext>(0);
		}
		public FuncOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterFuncOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitFuncOption(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncOptionContext funcOption() {
		FuncOptionContext _localctx = new FuncOptionContext(Context, State);
		EnterRule(_localctx, 122, RULE_funcOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 552;
			optionName();
			State = 553;
			Match(Colon);
			State = 554;
			optionValue();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Overflow() { return GetToken(FuncTestCaseParser.Overflow, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Rounding() { return GetToken(FuncTestCaseParser.Rounding, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NullHandling() { return GetToken(FuncTestCaseParser.NullHandling, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SpacesOnly() { return GetToken(FuncTestCaseParser.SpacesOnly, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(FuncTestCaseParser.Identifier, 0); }
		public OptionNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optionName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterOptionName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitOptionName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptionName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptionNameContext optionName() {
		OptionNameContext _localctx = new OptionNameContext(Context, State);
		EnterRule(_localctx, 124, RULE_optionName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 556;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 3151872L) != 0) || _la==Identifier) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptionValueContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Error() { return GetToken(FuncTestCaseParser.Error, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Saturate() { return GetToken(FuncTestCaseParser.Saturate, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Silent() { return GetToken(FuncTestCaseParser.Silent, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TieToEven() { return GetToken(FuncTestCaseParser.TieToEven, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NaN() { return GetToken(FuncTestCaseParser.NaN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Truncate() { return GetToken(FuncTestCaseParser.Truncate, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AcceptNulls() { return GetToken(FuncTestCaseParser.AcceptNulls, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IgnoreNulls() { return GetToken(FuncTestCaseParser.IgnoreNulls, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BooleanLiteral() { return GetToken(FuncTestCaseParser.BooleanLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NullLiteral() { return GetToken(FuncTestCaseParser.NullLiteral, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(FuncTestCaseParser.Identifier, 0); }
		public OptionValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optionValue; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterOptionValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitOptionValue(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptionValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptionValueContext optionValue() {
		OptionValueContext _localctx = new OptionValueContext(Context, State);
		EnterRule(_localctx, 126, RULE_optionValue);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 558;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 8796165365760L) != 0) || _la==Identifier) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FuncOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FuncOptionContext[] funcOption() {
			return GetRuleContexts<FuncOptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FuncOptionContext funcOption(int i) {
			return GetRuleContext<FuncOptionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] Comma() { return GetTokens(FuncTestCaseParser.Comma); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Comma(int i) {
			return GetToken(FuncTestCaseParser.Comma, i);
		}
		public FuncOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_funcOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterFuncOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitFuncOptions(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFuncOptions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FuncOptionsContext funcOptions() {
		FuncOptionsContext _localctx = new FuncOptionsContext(Context, State);
		EnterRule(_localctx, 128, RULE_funcOptions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 560;
			funcOption();
			State = 565;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==Comma) {
				{
				{
				State = 561;
				Match(Comma);
				State = 562;
				funcOption();
				}
				}
				State = 567;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NonReservedContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode And() { return GetToken(FuncTestCaseParser.And, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Or() { return GetToken(FuncTestCaseParser.Or, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Truncate() { return GetToken(FuncTestCaseParser.Truncate, 0); }
		public NonReservedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nonReserved; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterNonReserved(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitNonReserved(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNonReserved(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NonReservedContext nonReserved() {
		NonReservedContext _localctx = new NonReservedContext(Context, State);
		EnterRule(_localctx, 130, RULE_nonReserved);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 568;
			_la = TokenStream.LA(1);
			if ( !(_la==Truncate || _la==And || _la==Or) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NonReservedContext nonReserved() {
			return GetRuleContext<NonReservedContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Identifier() { return GetToken(FuncTestCaseParser.Identifier, 0); }
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IFuncTestCaseParserListener typedListener = listener as IFuncTestCaseParserListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IFuncTestCaseParserVisitor<TResult> typedVisitor = visitor as IFuncTestCaseParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(Context, State);
		EnterRule(_localctx, 132, RULE_identifier);
		try {
			State = 572;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case Truncate:
			case And:
			case Or:
				EnterOuterAlt(_localctx, 1);
				{
				State = 570;
				nonReserved();
				}
				break;
			case Identifier:
				EnterOuterAlt(_localctx, 2);
				{
				State = 571;
				Match(Identifier);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,120,575,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
		7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,35,
		2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,42,
		2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,
		2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,
		2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,
		2,64,7,64,2,65,7,65,2,66,7,66,1,0,1,0,4,0,137,8,0,11,0,12,0,138,1,0,1,
		0,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,3,5,3,157,8,3,
		10,3,12,3,160,9,3,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,172,8,5,
		1,5,1,5,1,5,1,6,1,6,4,6,179,8,6,11,6,12,6,180,1,6,1,6,4,6,185,8,6,11,6,
		12,6,186,3,6,189,8,6,1,7,1,7,1,7,5,7,194,8,7,10,7,12,7,197,9,7,1,8,1,8,
		3,8,201,8,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,
		9,1,9,1,9,1,9,3,9,221,8,9,1,10,1,10,1,10,1,10,1,10,3,10,228,8,10,1,10,
		1,10,1,10,1,11,1,11,1,11,1,11,3,11,237,8,11,1,11,1,11,1,11,1,11,1,11,1,
		11,3,11,245,8,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,3,11,254,8,11,1,12,
		1,12,1,12,1,12,1,12,1,12,5,12,262,8,12,10,12,12,12,265,9,12,1,12,1,12,
		1,12,1,12,1,13,1,13,1,13,1,13,5,13,275,8,13,10,13,12,13,278,9,13,3,13,
		280,8,13,1,13,1,13,1,14,1,14,1,14,1,14,1,15,1,15,1,15,1,15,5,15,292,8,
		15,10,15,12,15,295,9,15,3,15,297,8,15,1,15,1,15,1,16,1,16,1,16,1,16,1,
		16,1,16,1,16,1,16,1,16,1,16,1,16,3,16,312,8,16,1,17,1,17,1,17,5,17,317,
		8,17,10,17,12,17,320,9,17,1,18,1,18,1,18,5,18,325,8,18,10,18,12,18,328,
		9,18,1,19,1,19,1,19,1,19,3,19,334,8,19,1,20,1,20,1,20,1,20,3,20,340,8,
		20,1,21,1,21,1,21,3,21,345,8,21,1,22,1,22,1,23,1,23,1,23,1,23,1,24,1,24,
		1,24,1,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,1,27,1,27,1,27,1,27,
		1,28,1,28,1,28,1,28,1,29,1,29,1,29,1,29,1,30,1,30,1,30,1,30,1,31,1,31,
		1,31,1,31,1,32,1,32,1,32,1,32,1,33,1,33,1,33,1,33,1,34,1,34,1,34,1,34,
		1,35,1,35,1,35,1,35,1,36,1,36,1,36,1,36,1,37,1,37,1,37,1,37,1,38,1,38,
		1,38,1,38,1,39,1,39,1,39,1,39,1,40,1,40,1,40,1,40,1,41,1,41,1,41,1,41,
		5,41,425,8,41,10,41,12,41,428,9,41,3,41,430,8,41,1,41,1,41,1,42,1,42,3,
		42,436,8,42,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,
		1,43,1,43,1,43,1,43,1,43,3,43,455,8,43,1,44,1,44,1,45,1,45,1,46,1,46,1,
		47,1,47,1,48,1,48,1,49,1,49,1,50,1,50,3,50,471,8,50,1,50,1,50,1,50,1,50,
		3,50,477,8,50,1,51,1,51,3,51,481,8,51,1,51,1,51,1,51,1,51,1,52,1,52,3,
		52,489,8,52,1,52,1,52,1,52,1,52,1,53,1,53,3,53,497,8,53,1,53,1,53,1,53,
		1,53,1,54,1,54,3,54,505,8,54,1,54,1,54,1,54,1,54,1,54,1,54,3,54,513,8,
		54,1,55,1,55,3,55,517,8,55,1,55,1,55,1,55,1,55,1,56,1,56,3,56,525,8,56,
		1,56,1,56,1,56,1,56,1,57,1,57,3,57,533,8,57,1,57,1,57,1,57,1,57,1,58,1,
		58,1,58,1,58,1,58,1,58,1,58,1,58,3,58,547,8,58,1,59,1,59,1,60,1,60,1,61,
		1,61,1,61,1,61,1,62,1,62,1,63,1,63,1,64,1,64,1,64,5,64,564,8,64,10,64,
		12,64,567,9,64,1,65,1,65,1,66,1,66,3,66,573,8,66,1,66,0,0,67,0,2,4,6,8,
		10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,
		58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,
		104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,0,21,1,0,3,
		4,2,0,17,17,25,25,1,0,52,55,1,0,56,57,2,0,51,51,78,78,2,0,58,58,79,79,
		2,0,59,59,80,80,2,0,60,60,81,81,2,0,61,61,82,82,2,0,64,64,83,83,2,0,65,
		65,84,84,2,0,70,70,88,88,2,0,71,71,89,89,2,0,72,72,90,90,2,0,67,67,85,
		85,2,0,68,68,86,86,2,0,69,69,87,87,1,0,9,10,3,0,11,12,20,21,119,119,5,
		0,13,19,22,22,26,26,43,43,119,119,2,0,22,22,115,116,595,0,134,1,0,0,0,
		2,142,1,0,0,0,4,145,1,0,0,0,6,150,1,0,0,0,8,161,1,0,0,0,10,163,1,0,0,0,
		12,188,1,0,0,0,14,190,1,0,0,0,16,200,1,0,0,0,18,220,1,0,0,0,20,222,1,0,
		0,0,22,253,1,0,0,0,24,255,1,0,0,0,26,270,1,0,0,0,28,283,1,0,0,0,30,287,
		1,0,0,0,32,311,1,0,0,0,34,313,1,0,0,0,36,321,1,0,0,0,38,333,1,0,0,0,40,
		339,1,0,0,0,42,344,1,0,0,0,44,346,1,0,0,0,46,348,1,0,0,0,48,352,1,0,0,
		0,50,356,1,0,0,0,52,360,1,0,0,0,54,364,1,0,0,0,56,368,1,0,0,0,58,372,1,
		0,0,0,60,376,1,0,0,0,62,380,1,0,0,0,64,384,1,0,0,0,66,388,1,0,0,0,68,392,
		1,0,0,0,70,396,1,0,0,0,72,400,1,0,0,0,74,404,1,0,0,0,76,408,1,0,0,0,78,
		412,1,0,0,0,80,416,1,0,0,0,82,420,1,0,0,0,84,435,1,0,0,0,86,454,1,0,0,
		0,88,456,1,0,0,0,90,458,1,0,0,0,92,460,1,0,0,0,94,462,1,0,0,0,96,464,1,
		0,0,0,98,466,1,0,0,0,100,468,1,0,0,0,102,478,1,0,0,0,104,486,1,0,0,0,106,
		494,1,0,0,0,108,502,1,0,0,0,110,514,1,0,0,0,112,522,1,0,0,0,114,530,1,
		0,0,0,116,546,1,0,0,0,118,548,1,0,0,0,120,550,1,0,0,0,122,552,1,0,0,0,
		124,556,1,0,0,0,126,558,1,0,0,0,128,560,1,0,0,0,130,568,1,0,0,0,132,572,
		1,0,0,0,134,136,3,2,1,0,135,137,3,12,6,0,136,135,1,0,0,0,137,138,1,0,0,
		0,138,136,1,0,0,0,138,139,1,0,0,0,139,140,1,0,0,0,140,141,5,0,0,1,141,
		1,1,0,0,0,142,143,3,4,2,0,143,144,3,6,3,0,144,3,1,0,0,0,145,146,5,2,0,
		0,146,147,7,0,0,0,147,148,5,111,0,0,148,149,5,6,0,0,149,5,1,0,0,0,150,
		151,5,2,0,0,151,152,5,5,0,0,152,153,5,111,0,0,153,158,5,44,0,0,154,155,
		5,110,0,0,155,157,5,44,0,0,156,154,1,0,0,0,157,160,1,0,0,0,158,156,1,0,
		0,0,158,159,1,0,0,0,159,7,1,0,0,0,160,158,1,0,0,0,161,162,5,7,0,0,162,
		9,1,0,0,0,163,164,3,132,66,0,164,165,5,106,0,0,165,166,3,14,7,0,166,171,
		5,107,0,0,167,168,5,108,0,0,168,169,3,128,64,0,169,170,5,109,0,0,170,172,
		1,0,0,0,171,167,1,0,0,0,171,172,1,0,0,0,172,173,1,0,0,0,173,174,5,99,0,
		0,174,175,3,16,8,0,175,11,1,0,0,0,176,178,3,8,4,0,177,179,3,10,5,0,178,
		177,1,0,0,0,179,180,1,0,0,0,180,178,1,0,0,0,180,181,1,0,0,0,181,189,1,
		0,0,0,182,184,3,8,4,0,183,185,3,20,10,0,184,183,1,0,0,0,185,186,1,0,0,
		0,186,184,1,0,0,0,186,187,1,0,0,0,187,189,1,0,0,0,188,176,1,0,0,0,188,
		182,1,0,0,0,189,13,1,0,0,0,190,195,3,18,9,0,191,192,5,110,0,0,192,194,
		3,18,9,0,193,191,1,0,0,0,194,197,1,0,0,0,195,193,1,0,0,0,195,196,1,0,0,
		0,196,15,1,0,0,0,197,195,1,0,0,0,198,201,3,18,9,0,199,201,3,120,60,0,200,
		198,1,0,0,0,200,199,1,0,0,0,201,17,1,0,0,0,202,221,3,46,23,0,203,221,3,
		48,24,0,204,221,3,50,25,0,205,221,3,54,27,0,206,221,3,56,28,0,207,221,
		3,52,26,0,208,221,3,58,29,0,209,221,3,60,30,0,210,221,3,62,31,0,211,221,
		3,64,32,0,212,221,3,66,33,0,213,221,3,68,34,0,214,221,3,70,35,0,215,221,
		3,72,36,0,216,221,3,74,37,0,217,221,3,76,38,0,218,221,3,78,39,0,219,221,
		3,80,40,0,220,202,1,0,0,0,220,203,1,0,0,0,220,204,1,0,0,0,220,205,1,0,
		0,0,220,206,1,0,0,0,220,207,1,0,0,0,220,208,1,0,0,0,220,209,1,0,0,0,220,
		210,1,0,0,0,220,211,1,0,0,0,220,212,1,0,0,0,220,213,1,0,0,0,220,214,1,
		0,0,0,220,215,1,0,0,0,220,216,1,0,0,0,220,217,1,0,0,0,220,218,1,0,0,0,
		220,219,1,0,0,0,221,19,1,0,0,0,222,227,3,22,11,0,223,224,5,108,0,0,224,
		225,3,128,64,0,225,226,5,109,0,0,226,228,1,0,0,0,227,223,1,0,0,0,227,228,
		1,0,0,0,228,229,1,0,0,0,229,230,5,99,0,0,230,231,3,16,8,0,231,21,1,0,0,
		0,232,233,3,24,12,0,233,234,3,132,66,0,234,236,5,106,0,0,235,237,3,34,
		17,0,236,235,1,0,0,0,236,237,1,0,0,0,237,238,1,0,0,0,238,239,5,107,0,0,
		239,254,1,0,0,0,240,241,3,26,13,0,241,242,3,132,66,0,242,244,5,106,0,0,
		243,245,3,36,18,0,244,243,1,0,0,0,244,245,1,0,0,0,245,246,1,0,0,0,246,
		247,5,107,0,0,247,254,1,0,0,0,248,249,3,132,66,0,249,250,5,106,0,0,250,
		251,3,28,14,0,251,252,5,107,0,0,252,254,1,0,0,0,253,232,1,0,0,0,253,240,
		1,0,0,0,253,248,1,0,0,0,254,23,1,0,0,0,255,256,5,8,0,0,256,257,5,119,0,
		0,257,258,5,106,0,0,258,263,3,84,42,0,259,260,5,110,0,0,260,262,3,84,42,
		0,261,259,1,0,0,0,262,265,1,0,0,0,263,261,1,0,0,0,263,264,1,0,0,0,264,
		266,1,0,0,0,265,263,1,0,0,0,266,267,5,107,0,0,267,268,5,99,0,0,268,269,
		3,26,13,0,269,25,1,0,0,0,270,279,5,106,0,0,271,276,3,30,15,0,272,273,5,
		110,0,0,273,275,3,30,15,0,274,272,1,0,0,0,275,278,1,0,0,0,276,274,1,0,
		0,0,276,277,1,0,0,0,277,280,1,0,0,0,278,276,1,0,0,0,279,271,1,0,0,0,279,
		280,1,0,0,0,280,281,1,0,0,0,281,282,5,107,0,0,282,27,1,0,0,0,283,284,3,
		30,15,0,284,285,5,93,0,0,285,286,3,84,42,0,286,29,1,0,0,0,287,296,5,106,
		0,0,288,293,3,32,16,0,289,290,5,110,0,0,290,292,3,32,16,0,291,289,1,0,
		0,0,292,295,1,0,0,0,293,291,1,0,0,0,293,294,1,0,0,0,294,297,1,0,0,0,295,
		293,1,0,0,0,296,288,1,0,0,0,296,297,1,0,0,0,297,298,1,0,0,0,298,299,5,
		107,0,0,299,31,1,0,0,0,300,312,5,43,0,0,301,312,3,42,21,0,302,312,5,26,
		0,0,303,312,5,44,0,0,304,312,5,30,0,0,305,312,5,29,0,0,306,312,5,28,0,
		0,307,312,5,27,0,0,308,312,5,41,0,0,309,312,5,42,0,0,310,312,3,82,41,0,
		311,300,1,0,0,0,311,301,1,0,0,0,311,302,1,0,0,0,311,303,1,0,0,0,311,304,
		1,0,0,0,311,305,1,0,0,0,311,306,1,0,0,0,311,307,1,0,0,0,311,308,1,0,0,
		0,311,309,1,0,0,0,311,310,1,0,0,0,312,33,1,0,0,0,313,318,3,38,19,0,314,
		315,5,110,0,0,315,317,3,38,19,0,316,314,1,0,0,0,317,320,1,0,0,0,318,316,
		1,0,0,0,318,319,1,0,0,0,319,35,1,0,0,0,320,318,1,0,0,0,321,326,3,40,20,
		0,322,323,5,110,0,0,323,325,3,40,20,0,324,322,1,0,0,0,325,328,1,0,0,0,
		326,324,1,0,0,0,326,327,1,0,0,0,327,37,1,0,0,0,328,326,1,0,0,0,329,330,
		5,119,0,0,330,331,5,114,0,0,331,334,5,45,0,0,332,334,3,18,9,0,333,329,
		1,0,0,0,333,332,1,0,0,0,334,39,1,0,0,0,335,336,5,45,0,0,336,337,5,93,0,
		0,337,340,3,84,42,0,338,340,3,18,9,0,339,335,1,0,0,0,339,338,1,0,0,0,340,
		41,1,0,0,0,341,345,5,24,0,0,342,345,5,23,0,0,343,345,3,44,22,0,344,341,
		1,0,0,0,344,342,1,0,0,0,344,343,1,0,0,0,345,43,1,0,0,0,346,347,7,1,0,0,
		347,45,1,0,0,0,348,349,5,43,0,0,349,350,5,93,0,0,350,351,3,84,42,0,351,
		47,1,0,0,0,352,353,5,23,0,0,353,354,5,93,0,0,354,355,7,2,0,0,355,49,1,
		0,0,0,356,357,3,42,21,0,357,358,5,93,0,0,358,359,7,3,0,0,359,51,1,0,0,
		0,360,361,3,42,21,0,361,362,5,93,0,0,362,363,3,108,54,0,363,53,1,0,0,0,
		364,365,5,26,0,0,365,366,5,93,0,0,366,367,3,88,44,0,367,55,1,0,0,0,368,
		369,5,44,0,0,369,370,5,93,0,0,370,371,3,90,45,0,371,57,1,0,0,0,372,373,
		5,30,0,0,373,374,5,93,0,0,374,375,5,62,0,0,375,59,1,0,0,0,376,377,5,29,
		0,0,377,378,5,93,0,0,378,379,5,63,0,0,379,61,1,0,0,0,380,381,5,28,0,0,
		381,382,5,93,0,0,382,383,3,94,47,0,383,63,1,0,0,0,384,385,5,27,0,0,385,
		386,5,93,0,0,386,387,3,96,48,0,387,65,1,0,0,0,388,389,5,41,0,0,389,390,
		5,93,0,0,390,391,3,98,49,0,391,67,1,0,0,0,392,393,5,42,0,0,393,394,5,93,
		0,0,394,395,3,100,50,0,395,69,1,0,0,0,396,397,5,44,0,0,397,398,5,93,0,
		0,398,399,3,102,51,0,399,71,1,0,0,0,400,401,5,44,0,0,401,402,5,93,0,0,
		402,403,3,104,52,0,403,73,1,0,0,0,404,405,5,44,0,0,405,406,5,93,0,0,406,
		407,3,106,53,0,407,75,1,0,0,0,408,409,5,28,0,0,409,410,5,93,0,0,410,411,
		3,110,55,0,411,77,1,0,0,0,412,413,5,27,0,0,413,414,5,93,0,0,414,415,3,
		112,56,0,415,79,1,0,0,0,416,417,3,82,41,0,417,418,5,93,0,0,418,419,3,114,
		57,0,419,81,1,0,0,0,420,429,5,108,0,0,421,426,3,32,16,0,422,423,5,110,
		0,0,423,425,3,32,16,0,424,422,1,0,0,0,425,428,1,0,0,0,426,424,1,0,0,0,
		426,427,1,0,0,0,427,430,1,0,0,0,428,426,1,0,0,0,429,421,1,0,0,0,429,430,
		1,0,0,0,430,431,1,0,0,0,431,432,5,109,0,0,432,83,1,0,0,0,433,436,3,86,
		43,0,434,436,3,116,58,0,435,433,1,0,0,0,435,434,1,0,0,0,436,85,1,0,0,0,
		437,455,3,88,44,0,438,455,5,52,0,0,439,455,5,53,0,0,440,455,5,54,0,0,441,
		455,5,55,0,0,442,455,5,56,0,0,443,455,5,57,0,0,444,455,3,90,45,0,445,455,
		3,92,46,0,446,455,3,94,47,0,447,455,3,96,48,0,448,455,5,62,0,0,449,455,
		5,63,0,0,450,455,3,98,49,0,451,455,5,66,0,0,452,453,5,77,0,0,453,455,5,
		119,0,0,454,437,1,0,0,0,454,438,1,0,0,0,454,439,1,0,0,0,454,440,1,0,0,
		0,454,441,1,0,0,0,454,442,1,0,0,0,454,443,1,0,0,0,454,444,1,0,0,0,454,
		445,1,0,0,0,454,446,1,0,0,0,454,447,1,0,0,0,454,448,1,0,0,0,454,449,1,
		0,0,0,454,450,1,0,0,0,454,451,1,0,0,0,454,452,1,0,0,0,455,87,1,0,0,0,456,
		457,7,4,0,0,457,89,1,0,0,0,458,459,7,5,0,0,459,91,1,0,0,0,460,461,7,6,
		0,0,461,93,1,0,0,0,462,463,7,7,0,0,463,95,1,0,0,0,464,465,7,8,0,0,465,
		97,1,0,0,0,466,467,7,9,0,0,467,99,1,0,0,0,468,470,7,10,0,0,469,471,5,112,
		0,0,470,469,1,0,0,0,470,471,1,0,0,0,471,476,1,0,0,0,472,473,5,39,0,0,473,
		474,3,118,59,0,474,475,5,40,0,0,475,477,1,0,0,0,476,472,1,0,0,0,476,477,
		1,0,0,0,477,101,1,0,0,0,478,480,7,11,0,0,479,481,5,112,0,0,480,479,1,0,
		0,0,480,481,1,0,0,0,481,482,1,0,0,0,482,483,5,39,0,0,483,484,3,118,59,
		0,484,485,5,40,0,0,485,103,1,0,0,0,486,488,7,12,0,0,487,489,5,112,0,0,
		488,487,1,0,0,0,488,489,1,0,0,0,489,490,1,0,0,0,490,491,5,39,0,0,491,492,
		3,118,59,0,492,493,5,40,0,0,493,105,1,0,0,0,494,496,7,13,0,0,495,497,5,
		112,0,0,496,495,1,0,0,0,496,497,1,0,0,0,497,498,1,0,0,0,498,499,5,39,0,
		0,499,500,3,118,59,0,500,501,5,40,0,0,501,107,1,0,0,0,502,504,7,14,0,0,
		503,505,5,112,0,0,504,503,1,0,0,0,504,505,1,0,0,0,505,512,1,0,0,0,506,
		507,5,39,0,0,507,508,3,118,59,0,508,509,5,110,0,0,509,510,3,118,59,0,510,
		511,5,40,0,0,511,513,1,0,0,0,512,506,1,0,0,0,512,513,1,0,0,0,513,109,1,
		0,0,0,514,516,7,15,0,0,515,517,5,112,0,0,516,515,1,0,0,0,516,517,1,0,0,
		0,517,518,1,0,0,0,518,519,5,39,0,0,519,520,3,118,59,0,520,521,5,40,0,0,
		521,111,1,0,0,0,522,524,7,16,0,0,523,525,5,112,0,0,524,523,1,0,0,0,524,
		525,1,0,0,0,525,526,1,0,0,0,526,527,5,39,0,0,527,528,3,118,59,0,528,529,
		5,40,0,0,529,113,1,0,0,0,530,532,5,75,0,0,531,533,5,112,0,0,532,531,1,
		0,0,0,532,533,1,0,0,0,533,534,1,0,0,0,534,535,5,39,0,0,535,536,3,84,42,
		0,536,537,5,40,0,0,537,115,1,0,0,0,538,547,3,102,51,0,539,547,3,104,52,
		0,540,547,3,106,53,0,541,547,3,108,54,0,542,547,3,100,50,0,543,547,3,110,
		55,0,544,547,3,112,56,0,545,547,3,114,57,0,546,538,1,0,0,0,546,539,1,0,
		0,0,546,540,1,0,0,0,546,541,1,0,0,0,546,542,1,0,0,0,546,543,1,0,0,0,546,
		544,1,0,0,0,546,545,1,0,0,0,547,117,1,0,0,0,548,549,5,23,0,0,549,119,1,
		0,0,0,550,551,7,17,0,0,551,121,1,0,0,0,552,553,3,124,62,0,553,554,5,111,
		0,0,554,555,3,126,63,0,555,123,1,0,0,0,556,557,7,18,0,0,557,125,1,0,0,
		0,558,559,7,19,0,0,559,127,1,0,0,0,560,565,3,122,61,0,561,562,5,110,0,
		0,562,564,3,122,61,0,563,561,1,0,0,0,564,567,1,0,0,0,565,563,1,0,0,0,565,
		566,1,0,0,0,566,129,1,0,0,0,567,565,1,0,0,0,568,569,7,20,0,0,569,131,1,
		0,0,0,570,573,3,130,65,0,571,573,5,119,0,0,572,570,1,0,0,0,572,571,1,0,
		0,0,573,133,1,0,0,0,41,138,158,171,180,186,188,195,200,220,227,236,244,
		253,263,276,279,293,296,311,318,326,333,339,344,426,429,435,454,470,476,
		480,488,496,504,512,516,524,532,546,565,572
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
